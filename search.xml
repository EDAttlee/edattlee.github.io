<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Greetings!</title>
    <url>/2023/11/02/Greetings/</url>
    <content><![CDATA[<h2 id="Thanks-for-visiting-my-blog"><a href="#Thanks-for-visiting-my-blog" class="headerlink" title="Thanks for visiting my blog"></a>Thanks for visiting my blog</h2><p>Here I exhibit some of my  projects and research, and books I love. I’m interested in Deep-Learning, Robotics and Psychology. The primary objective of this blog is to encapsulate the myriad of technical challenges and insights I encounter on my educational journey, thereby aiding others. Furthermore, it serves as a practical application of the Feynman Technique, enhancing my own capacity for knowledge dissemination.</p>
<p>Should there be any inaccuracies or aspects of the blog that elicit confusion, please do not hesitate to contact me via email at your earliest convenience.</p>
]]></content>
  </entry>
  <entry>
    <title>Overview of innovative application for Diffusion</title>
    <url>/2023/11/01/Diffusion-4-Protein/</url>
    <content><![CDATA[<h1 id="Diffusion-Model-4-Protein"><a href="#Diffusion-Model-4-Protein" class="headerlink" title="Diffusion Model 4 Protein"></a>Diffusion Model 4 Protein</h1><p>​	Inverse protein folding is challenging due to its inherent one-to-many mapping</p>
<p>characteristic, where numerous possible amino acid sequences can fold into a single,</p>
<p>identical protein backbone. This task involves not only identifying viable sequences</p>
<p>but also representing the sheer diversity of potential solutions. This article is the overview of the technology utilized by <strong>Graph Denoising Diffusion for Inverse Protein Folding</strong>.</p>
<span id="more"></span>

<h2 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h2><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016220405922.png" alt="image-20231016220405922" style="zoom:33%;">

<p>​	残差学习就是改变传统的网络结构，将层间传输的数据转换为F(x)+x的形式。优势在于梯度不会随着导数的相乘而快速趋近于0，使得网络在达到Plateau后继续下降收敛。</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016220953678.png" alt="image-20231016220953678" style="zoom:33%;">

<h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><p>​	序列转录模型，运用Attention机制，取得了全局信息的抽取效果，而且避免了RNN存在的诸如梯度消失和难以并行计算的缺点。</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016221240166.png" alt="image-20231016221240166" style="zoom: 50%;">

<p>​	同样运用了Residual的链接方式和样本层面的layer norm，能够处理边长序列的样本信息。</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016221452280.png" alt="image-20231016221452280" style="zoom:33%;">

<p>​	此外，1）还要注意decoder的Mask机制，以及类似条件概率的序列生成方式 。2）Attention无法取得序列的位置信息，所以需要对位置进行cos的编码，使得MLP层能够学习到顺序Info。</p>
<h2 id="GNN"><a href="#GNN" class="headerlink" title="GNN"></a>GNN</h2><p>​	图神经网络利用的图这种数据结构intrinsically具有的强大特点，对于各种数据有这很好的结构化表示，详细介绍Distill：<a href="https://distill.pub/2021/gnn-intro/">A Gentle Introduction to Graph Neural Networks (distill.pub)</a></p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016222632434.png" alt="image-20231016222632434" style="zoom:67%;">

<p>​	对于一个图数据，可以对顶点、边以及全局信息分别应用MLP进行学习，在通过数据相互传到的技巧，可以良好地学习到数据整体地特征。</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016222814266.png" alt="image-20231016222814266" style="zoom:67%;">

<h2 id="What-is-GAN"><a href="#What-is-GAN" class="headerlink" title="What is GAN"></a>What is GAN</h2><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016223524288.png" alt="image-20231016224042238" style="zoom:50%;">

<p>​	GAN = Generative Adversarial Networks，生成对抗网络。即同时定义两个网络，生成器G和判别器D。通过博弈论新设计的目标函数，同时对两个网络进行对抗式的训练。最终达成的目的是使得G生产的图片非常趋近于Ground Truth的图片(图d)，而D无法分辨，收敛到1/2:</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016224042238.png" alt="image-20231016224042238" style="zoom:50%;">

<h2 id="Diffusion-Model-Overview-Via-DALLE-2"><a href="#Diffusion-Model-Overview-Via-DALLE-2" class="headerlink" title="Diffusion Model Overview Via DALLE-2"></a>Diffusion Model Overview Via DALLE-2</h2><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016225558737.png" alt="image-20231016225558737" style="zoom:50%;">

<p>​	概率扩散模型, 实用的DDPM运用残差学习的思想, 在Reverse过程中, 不通过Xt到Xt-1直接得到,而是学习所加的噪声. 因为通过共享权重的U-Net来进行全局的预测,需要对位置进行 Time Embeding. </p>
<h3 id="Classifier-Guided-Diffusion"><a href="#Classifier-Guided-Diffusion" class="headerlink" title="Classifier-Guided Diffusion"></a>Classifier-Guided Diffusion</h3><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016231307655.png" alt="image-20231016231307655" style="zoom: 50%;">

<p>​	Diffusion Beats GAN中提出的方法,不仅可以用Classifier来指导训练, CLIP, LLM等都可以用来作为Guide函数. </p>
<h3 id="Classifier-Free-Diffusion"><a href="#Classifier-Free-Diffusion" class="headerlink" title="Classifier-Free Diffusion"></a>Classifier-Free Diffusion</h3><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016231456302.png" alt="image-20231016231456302" style="zoom: 50%;">

<p>​	优化的目标函数变更. 通过学习有无条件生成X之间的Gap, 可以实现将即使在无条件下生成的图片转换成有条件Guide的图片. </p>
<h2 id="AlphaFold2"><a href="#AlphaFold2" class="headerlink" title="AlphaFold2"></a>AlphaFold2</h2><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016233300342.png" alt="image-20231016233300342" style="zoom:67%;">

<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016233824554.png" alt="image-20231016233824554" style="zoom:67%;">

<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231017004041504.png" alt="image-20231017004041504" style="zoom:67%;">

<p>​	Nature补充材料: <a href="https://www.nature.com/articles/s41586-021-03819-2#MOESM3">Highly accurate protein structure prediction with AlphaFold | Nature</a></p>
<h2 id="Turnover-number-DLKcat"><a href="#Turnover-number-DLKcat" class="headerlink" title="Turnover number &amp; DLKcat"></a>Turnover number &amp; DLKcat</h2><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016232316214.png" alt="image-20231016232316214" style="zoom: 67%;">

<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016232812110.png" alt="image-20231016232812110" style="zoom: 67%;">

<p>​	<strong>底物 Substrate</strong>: Substrate refers to the specific molecule or molecules that an enzyme acts upon in an enzymatic reaction. Enzymes bind to their substrates at their active sites, which are specific regions of the enzyme’s structure that complement the shape and chemical properties of the substrate(s). This binding of the substrate to the enzyme’s active site forms an enzyme-substrate complex.</p>
<h2 id="Protein-Graph"><a href="#Protein-Graph" class="headerlink" title="Protein Graph"></a>Protein Graph</h2><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016234338343.png" alt="image-20231016234338343" style="zoom:67%;">

<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231017012342420.png" alt="image-20231017012342420" style="zoom:67%;">

<h2 id="DataSet"><a href="#DataSet" class="headerlink" title="DataSet"></a>DataSet</h2><p><strong>CATH</strong>: Protein Structure Classification Database at UCL, which conducts 151 million protein domains classified into 5,841 superfamilies. 使用wget方法下载. </p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016004238773.png" alt="image-20231016004238773" style="zoom: 67%;">

<p><strong>Website</strong>: <a href="https://www.cathdb.info/">CATH: Protein Structure Classification Database at UCL (cathdb.info)</a></p>
<p><strong>Protein Domain</strong>: </p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016005008584.png" alt="image-20231016005008584" style="zoom:67%;"> 

<h2 id="Inductive-Bias-and-Learning-Rule"><a href="#Inductive-Bias-and-Learning-Rule" class="headerlink" title="Inductive Bias and Learning Rule"></a>Inductive Bias and Learning Rule</h2>]]></content>
      <categories>
        <category>AI4Science</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/10/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Hardware Develop</title>
    <url>/2023/08/29/Hardware-Develop/</url>
    <content><![CDATA[<h3 id="单片机开发-MCU-Development"><a href="#单片机开发-MCU-Development" class="headerlink" title="单片机开发 | MCU Development"></a>单片机开发 | MCU Development</h3><p>A microcontroller (MCU for microcontroller unit) is a compact integrated circuit designed to govern a specific operation in an embedded system. Typically, microcontrollers include an application-specific processor, memory, and input/output peripherals on a single chip. </p>
<p>By offering a customizable mix of read/write memory, program memory, and processing capability, microcontrollers make it economical to digitally control even more devices and processes.</p>
<p>Figure 1 depicts the circuit diagram we constructed within the simulation software to verify the rationality of the design.</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/proj_images/20231103155702942.png" referrerpolicy="no-referrer" alt="image-20231103155702942">

<span id="more"></span>

<p>The control of a system is inextricably linked to the collaborative operation of hardware electronic circuits and the computational processing of chips. In this course, we have delved into the underlying operational principles of computer systems and their hardware realizations, acquiring proficiency in assembly language, principles of compilation, and system hardware simulation. </p>
<p>Owing to the difficulty in modifying circuit PCB boards post-production, it is imperative to simulate the system circuitry prior to the actual soldering of hardware circuits and chips, to validate the feasibility of the code and design proposals. </p>
<p>As illustrated in Figure 2, the electronic password lock controlled by the C51 chip is presented, where we have learned how to employ matrix keyboards, utilize buzzers for music playback, and implement Bluetooth serial communication for data transfer among other hardware control and programming techniques.</p>
<h2 id="FPGA-Development"><a href="#FPGA-Development" class="headerlink" title="FPGA Development"></a>FPGA Development</h2><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/proj_images/20231103163321476.png" referrerpolicy="no-referrer" alt="image-20231103163321476">

<p>FPGAs (Field-Programmable Gate Arrays) are renowned for their abundant hardware resources, precise timing, and obviation of traditional gate circuits, offering high convenience and accuracy in development. They are extensively utilized in sectors such as communications, industry, and aerospace. Leveraging these attributes, learning FPGA enables the execution of highly precise timing and logic controls with minimal need for hardware expansion. This course has facilitated the mastery of EDA (Electronic Design Automation) frameworks and the Verilog hardware description language. Figure 3 presents a digital signal generator based on Verilog and FPGA, capable of generating various voltage signals with high precision.</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/proj_images/20231103163738899.png" referrerpolicy="no-referrer" alt="image-20231103163738899">

<p>After the programming component was validated through simulation, the hardware circuit was constructed. Utilizing peripheral hardware circuits, we have implemented the functionality to switch between different waveforms, as well as adjust their amplitude and frequency. The right image displays the waveform output as captured by an oscilloscope.</p>
]]></content>
      <categories>
        <category>Hardware</category>
      </categories>
  </entry>
  <entry>
    <title>Projects in Course Robotics</title>
    <url>/2023/08/24/Robot/</url>
    <content><![CDATA[<h2 id="机器人课程总结-Robotics"><a href="#机器人课程总结-Robotics" class="headerlink" title="机器人课程总结 | Robotics"></a>机器人课程总结 | Robotics</h2><h3 id="六关节机械臂ROS仿真与实验"><a href="#六关节机械臂ROS仿真与实验" class="headerlink" title="六关节机械臂ROS仿真与实验"></a>六关节机械臂ROS仿真与实验</h3><p><img src="/.com//Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20231103173145487.png" alt="image-20231103173145487"></p>
<p>In industrial applications, robotic arms with multiple joints possess a high degree of freedom, necessitating the spatial modeling of nodes and linkages, known as the DH (Denavit-Hartenberg) parameter table. Euler coordinate transformations are applied to convert joint space into Cartesian coordinate space to accomplish specific operational tasks. Figure 1 showcases a classic 6DOF (Degrees of Freedom) robot and a recognition and grasping task based on GAZEBO machine vision.</p>
<span id="more"></span>

<h3 id="运用手势识别的机械臂位姿控制"><a href="#运用手势识别的机械臂位姿控制" class="headerlink" title="运用手势识别的机械臂位姿控制"></a>运用手势识别的机械臂位姿控制</h3><p>After the robotic arm modeling is complete, the classic PID algorithm from automatic control theory, integrated with computer vision (CV), can be employed to control a three-jointed robotic arm using hand gestures. As shown in Figure 2, the robotic arm rapidly adjusts its end position in response to the recognized different gestures and orientations</p>
<p><img src="/.com//Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20231103173348576.png" alt="image-20231103173348576"></p>
<h3 id="SLAM技术与无人车控制"><a href="#SLAM技术与无人车控制" class="headerlink" title="SLAM技术与无人车控制"></a>SLAM技术与无人车控制</h3><img src="/.com//Blog\source\proj_images\SLAM例图.png" alt="SLAM例图" style="zoom: 50%;">

<p>SLAM (Simultaneous Localization and Mapping) technology is a computational method that enables a robot or an autonomous vehicle to map its environment while simultaneously keeping track of its own location within that environment. SLAM is critical in the fields of robotics and autonomous systems, as it allows for navigation in unknown spaces without the need for external references like GPS</p>
<img src="/.com//Blog\source\proj_images\slam2.png" alt="slam2" style="zoom:50%;">

<p>We have conducted map construction of the academic building and controlled the movement of an intelligent vehicle accordingly. This process likely involved using SLAM technology to enable the smart car to navigate through the building, creating a map as it moved along.</p>
]]></content>
      <categories>
        <category>Hardware</category>
      </categories>
  </entry>
  <entry>
    <title>在 Ubuntu 上安装 CUDA 及 cuDNN</title>
    <url>/2023/07/24/Ubuntu/</url>
    <content><![CDATA[<p>记录一次痛苦安装 CUDA 及 cuDNN，希望以后不幸需要再装时能轻松些。<br> <span id="more"></span></p>
<h2 id="安装-nVidia-显卡驱动"><a href="#安装-nVidia-显卡驱动" class="headerlink" title="安装 nVidia 显卡驱动"></a>安装 nVidia 显卡驱动</h2><p>首先需要确保安装了 nVidia 的驱动，安装方法在此不赘述。<br>如果安装了可以在终端中查看显卡信息，包括支持的 CUDA 最大版本</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></tbody></table></figure>

<h2 id="安装-CUDA"><a href="#安装-CUDA" class="headerlink" title="安装 CUDA"></a>安装 CUDA</h2><p>在 nVidia 官网选择需要下载的版本，为了兼容 PyTorch 我选择了11.7：<br><a href="https://developer.nvidia.com/cuda-11-7-0-download-archive">https://developer.nvidia.com/cuda-11-7-0-download-archive</a><br>Ubuntu 版官方给出了三种安装方式，我使用的是第一种。直接按照步骤执行就没问题。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/cuda-ubuntu2004.pin</span><br><span class="line">sudo mv cuda-ubuntu2004.pin /etc/apt/preferences.d/cuda-repository-pin-600</span><br><span class="line">wget https://developer.download.nvidia.com/compute/cuda/11.7.0/local_installers/cuda-repo-ubuntu2004-11-7-local_11.7.0-515.43.04-1_amd64.deb</span><br><span class="line">sudo dpkg -i cuda-repo-ubuntu2004-11-7-local_11.7.0-515.43.04-1_amd64.deb</span><br><span class="line">sudo cp /var/cuda-repo-ubuntu2004-11-7-local/cuda-*-keyring.gpg /usr/share/keyrings/</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install cuda</span><br></pre></td></tr></tbody></table></figure>

<p><strong>更新：直接用第三种吧，省事，而且最重要的是可以不安装配套版本驱动，少点问题，第一种会自动替换驱动版本</strong></p>
<h2 id="检测-CUDA-安装"><a href="#检测-CUDA-安装" class="headerlink" title="检测 CUDA 安装"></a>检测 CUDA 安装</h2><p>终端中输入</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></tbody></table></figure>

<p>如果正常显示 CUDA 版本等信息则说明安装成功</p>
<h2 id="安装-cuDNN"><a href="#安装-cuDNN" class="headerlink" title="安装 cuDNN"></a>安装 cuDNN</h2><p>在如下链接可以下载历史版本的 cuDNN，需要登录 nVidia账号：<br><a href="https://developer.nvidia.com/rdp/cudnn-archive">https://developer.nvidia.com/rdp/cudnn-archive</a><br>安装方法可以参考官方的文档：<br><a href="https://docs.nvidia.com/deeplearning/cudnn/install-guide/index.html">https://docs.nvidia.com/deeplearning/cudnn/install-guide/index.html</a></p>
<p>1.下载所需版本的 Deb 文件</p>
<p>2.使用 dpkg 安装所得 Deb文件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo dpkg -i cudnn-local-repo-${distro}-8.x.x.x_1.0-1_amd64.deb</span><br></pre></td></tr></tbody></table></figure>

<p>3.前往/var/cudnn-local-repo-${distro}-8.x.x.x/目录，安装相关库文件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo dpkg -i libcudnn8_8.x.x.x-1+cudaX.Y_amd64.deb </span><br><span class="line">sudo dpkg -i libcudnn8-dev_8.x.x.x-1+cudaX.Y_amd64.deb </span><br><span class="line">sudo dpkg -i libcudnn8-samples_8.x.x.x-1+cudaX.Y_amd64.deb   </span><br></pre></td></tr></tbody></table></figure>

<h2 id="测试-cuDNN-安装"><a href="#测试-cuDNN-安装" class="headerlink" title="测试 cuDNN 安装"></a>测试 cuDNN 安装</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cp -r /usr/src/cudnn_samples_v8/ $HOME</span><br><span class="line">cd  $HOME/cudnn_samples_v8/mnistCUDNN</span><br><span class="line">make clean &amp;&amp; make</span><br><span class="line">./mnistCUDNN</span><br></pre></td></tr></tbody></table></figure>

<p>在 make 时可能会存在库缺失的报错，这不一定是 cuDNN 的问题。</p>
<p>例如我在验证时报错：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">test.c:1:10: fatal error: FreeImage.h: 没有那个文件或目录</span><br><span class="line">    1 | #include "FreeImage.h"</span><br><span class="line">      |          ^~~~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br><span class="line">&gt;&gt;&gt; WARNING - FreeImage is not set up correctly. Please ensure FreeImage is set up correctly. &lt;&lt;&lt;</span><br></pre></td></tr></tbody></table></figure>

<p>解决方案是安装 FreeImage 库就行</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libfreeimage-dev</span><br></pre></td></tr></tbody></table></figure>

<p>如果成果安装 cuDNN，最后运行 mnistCUDNN 时最后一行输出</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Test passed!</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>使用简单的遗传算法求解函数的最大值</title>
    <url>/2023/04/09/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>人工智能课上学了点遗传算法，记录搓的一段比较简单的实现代码，实现求解<br>$$<br>f(x)=xe^{sin(2\pi x)}<br>$$<br>在区间 $[0,5]$ 的最大值<br>(参数和算法设计不一定合理)<br> <span id="more"></span><br>计算适应度函数，在此直接以 $f(x)$ 的值作为适应度</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fitness_function</span>(<span class="params">solution</span>):</span><br><span class="line">    fitness = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(chromosome_length):</span><br><span class="line">        fitness = fitness + solution[i] * <span class="number">2</span>**i</span><br><span class="line">    <span class="comment"># Return the fitness of a solution</span></span><br><span class="line">    fitness = fitness/(<span class="number">2</span>**chromosome_length-<span class="number">1</span>)*<span class="number">5</span></span><br><span class="line">    <span class="keyword">return</span> fitness*math.exp(math.sin(<span class="number">2</span>*math.pi*fitness))</span><br></pre></td></tr></tbody></table></figure>

<p>染色体单点交叉函数</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">one_point_crossover</span>(<span class="params">chromosome1, chromosome2</span>):</span><br><span class="line">    <span class="comment"># Select a random crossover point</span></span><br><span class="line">    crossover_point = random.randint(<span class="number">1</span>, <span class="built_in">len</span>(chromosome1) - <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># Create two new offspring chromosomes by swapping genetic information</span></span><br><span class="line">    offspring1 = chromosome1[:crossover_point] + chromosome2[crossover_point:]</span><br><span class="line">    offspring2 = chromosome2[:crossover_point] + chromosome1[crossover_point:]</span><br><span class="line">    <span class="comment"># Return the two new offspring chromosomes</span></span><br><span class="line">    <span class="keyword">return</span> offspring1, offspring2</span><br></pre></td></tr></tbody></table></figure>

<p>参数定义，以及初始化种群</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Define the genetic algorithm parameters</span></span><br><span class="line">population_size = <span class="number">200</span></span><br><span class="line">chromosome_length = <span class="number">17</span></span><br><span class="line">mutation_rate = <span class="number">0.01</span></span><br><span class="line">crossover_rate = <span class="number">0.5</span></span><br><span class="line">generations = <span class="number">300</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the population</span></span><br><span class="line">population = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(population_size):</span><br><span class="line">    chromosome = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(chromosome_length):</span><br><span class="line">        chromosome.append(random.randint(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    population.append(chromosome)</span><br></pre></td></tr></tbody></table></figure>

<p>算法主体</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># Run the genetic algorithm</span></span><br><span class="line"><span class="keyword">for</span> generation <span class="keyword">in</span> <span class="built_in">range</span>(generations):</span><br><span class="line">    <span class="comment"># Evaluate the fitness of each solution in the population</span></span><br><span class="line">    fitness_scores = []</span><br><span class="line">    <span class="keyword">for</span> chromosome <span class="keyword">in</span> population:</span><br><span class="line">        fitness_scores.append(fitness_function(chromosome))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Select the fittest individuals for reproduction</span></span><br><span class="line">    selected_population = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(population_size//<span class="number">3</span>):</span><br><span class="line">        chromosome1 = random.choices(population, weights=fitness_scores)[<span class="number">0</span>]</span><br><span class="line">        chromosome2 = random.choices(population, weights=fitness_scores)[<span class="number">0</span>]</span><br><span class="line">        selected_population.append(chromosome1)</span><br><span class="line">        selected_population.append(chromosome2)</span><br><span class="line">        <span class="keyword">if</span> random.random() &lt; crossover_rate:</span><br><span class="line">            offspring1, offspring2 = one_point_crossover(</span><br><span class="line">                chromosome1, chromosome2)</span><br><span class="line">            selected_population.append(offspring1)</span><br><span class="line">            selected_population.append(offspring2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Apply mutations to the selected population</span></span><br><span class="line">    mutated_population = []</span><br><span class="line">    <span class="keyword">for</span> chromosome <span class="keyword">in</span> selected_population:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(chromosome_length):</span><br><span class="line">            <span class="keyword">if</span> random.random() &lt; mutation_rate:</span><br><span class="line">                chromosome[i] = <span class="number">1</span> - chromosome[i]</span><br><span class="line">        mutated_population.append(chromosome)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Replace the old population with the new population</span></span><br><span class="line">    population = mutated_population</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print the fittest solution for each generation</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Generation:"</span>, generation, <span class="string">"Fittest solution:"</span>, <span class="built_in">max</span>(fitness_scores))</span><br></pre></td></tr></tbody></table></figure>

<p>输出示例（部分）</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Generation: 295 Fittest solution: 11.560699289395993</span><br><span class="line">Generation: 296 Fittest solution: 11.560699289395993</span><br><span class="line">Generation: 297 Fittest solution: 11.560720015712006</span><br><span class="line">Generation: 298 Fittest solution: 11.560790129849646</span><br><span class="line">Generation: 299 Fittest solution: 11.560790129849646</span><br></pre></td></tr></tbody></table></figure>

<p>可见准确度在误差允许的范围内</p>
]]></content>
  </entry>
  <entry>
    <title>在 WSL2 中安装 MySQL 并通过 Windows 本地连接</title>
    <url>/2023/04/08/MySQL/</url>
    <content><![CDATA[<blockquote>
<p>转载，原文地址:<a href="https://mysteriouspreserve.com/blog/2022/11/06/WSL2-MySQL/">https://mysteriouspreserve.com/blog/2022/11/06/WSL2-MySQL/</a></p>
</blockquote>
<p>在 WSL2 上安装的 MySQL 无法在 Windows 上直接由 127.0.0.1 访问，在此记录配置 MySQL 远程连接使得 Windows 的 SQL 管理软件可以直接管理 WSL2 里的 MySQL的方法。<br> <span id="more"></span></p>
<p>首先开启 WSL2 的 systemd：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">vim /etc/wsl.conf</span><br></pre></td></tr></tbody></table></figure>

<p>然后在其中添加如下内容：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[boot]</span></span><br><span class="line"><span class="attr">systemd</span>=<span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<p>上述也可以用如下指令实现：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo -e "[boot]\nsystemd=true" | sudo tee -a /etc/wsl.conf</span><br></pre></td></tr></tbody></table></figure>

<p>退出 WSL2，使用 <code>wsl --shutdown</code> 关闭 WSL2</p>
<p>再次启动 WSL2，安装 MySQL：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt install mysql-server</span><br></pre></td></tr></tbody></table></figure>

<p>修改 <code>/etc/mysql/mysql.conf.d/mysqld.cnf</code> 中的 <code>bind-address</code> 为 <code>0.0.0.0</code>，使得 MySQL 允许外部访问</p>
<p>重启 MySQL，并初始化 MySQL：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo /etc/init.d/mysql restart</span><br><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></tbody></table></figure>

<p>进入MySQL，开放外部权限：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo mysql -u root -p</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> host<span class="operator">=</span>"%" <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span>"root";</span><br></pre></td></tr></tbody></table></figure>

<p>最后更改 iptable 防火墙规则并保存：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo iptables -A INPUT -p tcp -m tcp --dport 3306 -j ACCEPT</span><br><span class="line">sudo iptables-save -c</span><br></pre></td></tr></tbody></table></figure>

<p>至此便可以让 Windows 通过本地 127.0.0.1:3306 访问 WSL2 的 MySQL Server</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>数字控制器的离散化设计技术</title>
    <url>/2023/04/01/MotionControl/</url>
    <content><![CDATA[<h2 id="数字控制器的离散化设计步骤"><a href="#数字控制器的离散化设计步骤" class="headerlink" title="数字控制器的离散化设计步骤"></a>数字控制器的离散化设计步骤</h2><p>计算机控制系统框图如下图所示：</p>
<p><img src="https://zilchme.github.io/pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E6%A1%86%E5%9B%BE.png" alt="计算机控制系统框图"><br>可得其闭环脉冲函数为：<br>$$<br>\Phi(z)=\frac{D(z) G(z)}{1+D(z) G(z)}<br>$$<br>其中，$G(z)=Z[H(s)G_c(s)]$，为控制对象加上零阶保持器后的离散化。<br><br>反推可知：<br>$$<br>D(z)=\frac{\Phi(z)}{G(z)(1-\Phi(z))}=\frac{\Phi(z)}{G(z) \Phi_e(z)}<br>$$<br>设计最少拍控制器，通常根据性能要求和约束条件确定所需的$\Phi(z)$和$\Phi_e(z)$，再得到$D(z)$。<br> <span id="more"></span></p>
<h2 id="最少拍有纹波控制器的设计"><a href="#最少拍有纹波控制器的设计" class="headerlink" title="最少拍有纹波控制器的设计"></a>最少拍有纹波控制器的设计</h2><h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h3><p>根据终值定理可求出系统的稳态误差：<br>$$<br>\begin{aligned}<br>e(\infty) &amp; =\lim <em>{z \rightarrow 1}\left(1-z^{-1}\right) E(z)=\lim</em>{z \rightarrow 1}\left(1-z^{-1}\right) R(z) \Phi_e(z) \<br>&amp; =\lim _{z \rightarrow 1}\left(1-z^{-1}\right) \frac{B(z)}{\left(1-z^{-1}\right)^q} \Phi_e(z)<br>\end{aligned}<br>$$<br>我们希望稳态误差为0，且过渡过程步数最少，于是我们从中可以得到如下结论：</p>
<ol>
<li>$\Phi_e(z)$的设计与$R(z)$的阶次相关，并且我们要抵消其在$z=1$上的极点，即$\Phi_e(z)$要包含$\left(1-z^{-1}\right)^q$</li>
<li>为了步数最少，$\Phi_e(z)$中其他关于$z^{-1}$的幂次要尽可能低</li>
</ol>
<p>此外，我们还需要考虑$D(z)$的<strong>可实现性问题和稳定性问题</strong>：</p>
<ul>
<li><strong>可实现性</strong><br>$D(z)$中不能含有超前环节，即分母阶次大于等于分子，设计时若广义脉冲传递函数$G(z)$的分母比分子高N阶，则确定$\Phi(z)$时必须至少分母比分子高N阶;若被控对象有滞后特性，$\Phi(z)$中必须含有纯滞后，且滞后时间至少要等于被控对象的滞后时间。</li>
<li><strong>稳定性</strong><br>最小拍系统的设计前提是$G(z)$在单位圆上或圆外没有零极点，或能被$\Phi(z)$及$\Phi_e(z)$补偿，即：<ul>
<li>$\Phi_e(z)$的零点中，必须包含$G(z)$在<strong>单位圆上或圆外</strong>的所有极点；</li>
<li>$\Phi(z)$的零点中，必须包含$G(z)$在<strong>单位圆上或圆外</strong>的所有零点；</li>
</ul>
</li>
</ul>
<h3 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h3><p>综上所述，可以总结出设计最少拍有纹波控制器的一般步骤(应试):</p>
<ol>
<li>求取广义对象的脉冲传递函数$G(z)=Z[H(s)G_c(s)]$</li>
<li>依据$R(z)$的阶次和$G(z)$的零极点分布确定$\Phi_e(z)$和$\Phi(z)$和的形式。由$\Phi(z)=1-\Phi_e(z)$，比较系数法得到$\Phi_e(z)$和$\Phi(z)$</li>
<li>得到调节模型<br>$$D(z)=\frac{\Phi(z)}{G(z) \Phi_e(z)}$$</li>
</ol>
<h2 id="最少拍无纹波控制器的设计"><a href="#最少拍无纹波控制器的设计" class="headerlink" title="最少拍无纹波控制器的设计"></a>最少拍无纹波控制器的设计</h2><h3 id="为什么会有纹波"><a href="#为什么会有纹波" class="headerlink" title="为什么会有纹波"></a>为什么会有纹波</h3><p>纹波的产生在于控制信号$u(k)$无法在有限个周期内达到稳态，经过采样后给被控对象$G_c(s)$的控制信号$u(t)$无法达到稳态，使得输出产生纹波。</p>
<h3 id="系统无纹波的要求"><a href="#系统无纹波的要求" class="headerlink" title="系统无纹波的要求"></a>系统无纹波的要求</h3><p>显然，无纹波最小拍系统要求$U(z)$为$z^{-1}$的有限多项式<br>$$U(z)=E(z)D(z)=D(z)\Phi_e(z)R(z)$$<br>在设计最小拍系统时，已经保证了$\Phi_e(z)$的零点完全对消$R(z)$的极点<br><br>又有：<br>$$D(z)\Phi_e(z)=\frac{\Phi(z)}{G(z)}$$<br>故只需保证$\Phi(z)$的零点完全对消$G(z)$的零点即可。</p>
<p><strong>综上所述，设计无纹波系统时，只需在有纹波系统的条件下附加一条：</strong></p>
<ul>
<li>$\Phi(z)$的零点<strong>完全对消</strong>$G(z)$的零点</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Java画图板</title>
    <url>/2020/01/10/Java%E7%BB%98%E5%9B%BE%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="Java界面实现的简单绘图板"><a href="#Java界面实现的简单绘图板" class="headerlink" title="Java界面实现的简单绘图板"></a>Java界面实现的简单绘图板</h2><h3 id="创建界面与面板"><a href="#创建界面与面板" class="headerlink" title="创建界面与面板"></a>创建界面与面板</h3><p>创建界面与实现监听的具体方式笔者已经在之前的博客中进行了详细的介绍，这里就不再赘述。</p>
<span id="more"></span>

<p>首先我们创建一个界面，并在界面中设置面板区域：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">		JFrame jf=<span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br><span class="line">		jf.setTitle(<span class="string">"绘图板"</span>);	jf.setSize(<span class="number">800</span>, <span class="number">800</span>);</span><br><span class="line">		jf.setDefaultCloseOperation(<span class="number">3</span>);	</span><br><span class="line">		jf.setLocationRelativeTo(<span class="literal">null</span>);</span><br><span class="line">		jf.setResizable(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//		创建界面</span></span><br><span class="line">		jf.setLayout(<span class="keyword">new</span> <span class="title class_">BorderLayout</span>());</span><br><span class="line"><span class="comment">//		规定排列方式</span></span><br><span class="line">		JPanel jpn=<span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">		jpn.setPreferredSize(<span class="keyword">new</span> <span class="title class_">Dimension</span>(<span class="number">0</span>,<span class="number">80</span>));</span><br><span class="line">		jpn.setBackground(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">111</span>,<span class="number">119</span>,<span class="number">219</span>));</span><br><span class="line">		JPanel jps=<span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">		jps.setPreferredSize(<span class="keyword">new</span> <span class="title class_">Dimension</span>(<span class="number">0</span>,<span class="number">120</span>));</span><br><span class="line">		jps.setBackground(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">61</span>,<span class="number">232</span>,<span class="number">254</span>));</span><br><span class="line">		JPanel jpe=<span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">		jpe.setPreferredSize(<span class="keyword">new</span> <span class="title class_">Dimension</span>(<span class="number">20</span>,<span class="number">0</span>));</span><br><span class="line">		jpe.setBackground(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">61</span>,<span class="number">232</span>,<span class="number">254</span>));</span><br><span class="line">		JPanel jpw=<span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">		jpw.setPreferredSize(<span class="keyword">new</span> <span class="title class_">Dimension</span>(<span class="number">20</span>,<span class="number">0</span>));</span><br><span class="line">		jpw.setBackground(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">61</span>,<span class="number">232</span>,<span class="number">254</span>));</span><br><span class="line">		JPanel jpc=<span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line"><span class="comment">//		添加位于界面四个方向的面板区域</span></span><br></pre></td></tr></tbody></table></figure>
<p>在这几行代码中，我们为每个面板规定了大小和背景色。但要注意的有：</p>
<ul>
<li><p>南北（上下）方向的面板宽度规定为整个界面，东西（左右）方向的面板高度规定为顶格至南北方向面板，所以我们无需再考虑已经规定的长度，写成0即可。</p>
</li>
<li><p>中央的面板的大小在其余四个方向面板规定后就无需设置，当然，设置了也没有问题，但要注意大小，不然可能会有“画出界”的情况发生。</p>
</li>
<li><p>设置的背景色可以用color（R，G，B）来实现，用一般电脑自带的画图软件就能够获取心仪颜色的参数：</p>
</li>
</ul>
  <img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/201910231550075.png" alt="在这里插入图片描述" style="zoom:67%">

<p>  记得将每个面板添加到界面中<code>jf.add(jpn,BorderLayout.NORTH)；    ......jf.add(jpc,BorderLayout.CENTER);</code> 并设置其添加方向。<br>  这样一个画图板界面就初步实现了：</p>
  <img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191023155248613.png?" alt="在这里插入图片描述" style="zoom:67%">
###  不同画图选项按钮的添加
因为需要添加的按钮较多，直接依次写入会使得代码显得冗长，所以我们定义两个数组（规定返回值的类型），用for循环来帮我们添加
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Color[] btnColors = {Color.red,Color.blue,Color.orange,Color.yellow,Color.black};</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; btnColors.length; i++) {</span><br><span class="line">	<span class="type">JButton</span> <span class="variable">cbtn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>();</span><br><span class="line">	cbtn.setPreferredSize(<span class="keyword">new</span> <span class="title class_">Dimension</span>(<span class="number">60</span>,<span class="number">28</span>));</span><br><span class="line">	cbtn.setBackground(btnColors[i]);</span><br><span class="line">	jpn.add(cbtn);</span><br><span class="line">	cbtn.addActionListener(drl);</span><br><span class="line">	}</span><br><span class="line">String[] btnStrings={<span class="string">"直线"</span>,<span class="string">"矩形"</span>,<span class="string">"圆形"</span>,<span class="string">"三角形"</span>,<span class="string">"分形"</span>,<span class="string">"多边形"</span>};	</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">6</span>;j++){</span><br><span class="line">	JButton sbtn=<span class="keyword">new</span> <span class="title class_">JButton</span>(btnStrings[j]);</span><br><span class="line">	sbtn.setPreferredSize(<span class="keyword">new</span> <span class="title class_">Dimension</span>(<span class="number">100</span>,<span class="number">28</span>));</span><br><span class="line">	sbtn.setBackground(Color.WHITE);</span><br><span class="line">	jpn.add(sbtn);</span><br><span class="line">	sbtn.addActionListener(drl);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
除了几个既定的颜色，我们再添加一个颜色自选按钮，稍后在实现监听中我们再对它进行更详细的解释：
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">JButton ccl=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"自选色"</span>);</span><br><span class="line">		ccl.setPreferredSize(<span class="keyword">new</span> <span class="title class_">Dimension</span>(<span class="number">80</span>,<span class="number">28</span>));</span><br><span class="line">		ccl.setBackground(Color.LIGHT_GRAY);</span><br><span class="line">		jpn.add(ccl);</span><br><span class="line">		ccl.addActionListener(drl);</span><br></pre></td></tr></tbody></table></figure>
此时执行结果如下

<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/2019102317095287.png" alt="在这里插入图片描述" style="zoom:67%">

<h3 id="画图动作的监听与实现"><a href="#画图动作的监听与实现" class="headerlink" title="画图动作的监听与实现"></a>画图动作的监听与实现</h3><p>为了实现一个画图板，我们需要给监听器引用两个接口，即 MouseListener和ActionListener。我们先定义变量和抽象方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> x1, x2, y1, y2, x3, y3, x4, y4, x5, y5;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>,ncount=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> nx0,ny0,nx1,nx2,ny1,ny2;</span><br><span class="line">Graphics graw;</span><br><span class="line"><span class="type">String</span> <span class="variable">sbtn</span> <span class="operator">=</span> <span class="string">"直线"</span>;</span><br><span class="line">Pad3DBall pad3dball;</span><br></pre></td></tr></tbody></table></figure>
<p>之后我们重载这些方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> {</span><br><span class="line">	sbtn = e.getActionCommand();</span><br><span class="line">	System.out.println(sbtn);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sbtn.equals(<span class="string">"分形"</span>)) {</span><br><span class="line">		<span class="type">Pad3DBall</span> <span class="variable">pad3dball</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pad3DBall</span>();</span><br><span class="line">		pad3dball.intUI();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sbtn.equals(<span class="string">""</span>)) {</span><br><span class="line">		<span class="type">JButton</span> <span class="variable">cbtn</span> <span class="operator">=</span> (JButton) e.getSource();</span><br><span class="line">		<span class="type">Color</span> <span class="variable">c1</span> <span class="operator">=</span> cbtn.getBackground();</span><br><span class="line">		graw.setColor(c1);</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (sbtn.equals(<span class="string">"自选色"</span>)){</span><br><span class="line">		<span class="type">Color</span> <span class="variable">c2</span> <span class="operator">=</span> JColorChooser.showDialog(<span class="literal">null</span>, <span class="string">"颜色提取器"</span>, Color.LIGHT_GRAY);</span><br><span class="line">		graw.setColor(c2);</span><br><span class="line">		JButton ccl=(JButton) e.getSource();</span><br><span class="line">		ccl.setBackground(c2);		</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseClicked</span><span class="params">(MouseEvent e)</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (sbtn.equals(<span class="string">"三角形"</span>)) {</span><br><span class="line">		count++;</span><br><span class="line">		System.out.println(<span class="string">"点击"</span>);</span><br><span class="line">		<span class="keyword">if</span> (count == <span class="number">1</span>) {</span><br><span class="line">			x3 = e.getX();</span><br><span class="line">			y3 = e.getY();</span><br><span class="line">		} <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">2</span>) {</span><br><span class="line">			x4 = e.getX();</span><br><span class="line">			y4 = e.getY();</span><br><span class="line">			graw.drawLine(x3, y3, x4, y4);</span><br><span class="line">		} <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">3</span>) {</span><br><span class="line">			x5 = e.getX();</span><br><span class="line">			y5 = e.getY();</span><br><span class="line">			graw.drawLine(x3, y3, x5, y5);</span><br><span class="line">			graw.drawLine(x4, y4, x5, y5);</span><br><span class="line">			count = <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (sbtn.equals(<span class="string">"多边形"</span>)) {</span><br><span class="line">		ncount++;</span><br><span class="line">		System.out.println(<span class="string">"单击"</span>);</span><br><span class="line">		<span class="keyword">if</span> (ncount == <span class="number">1</span>) {</span><br><span class="line">			x3 = e.getX();</span><br><span class="line">			y3 = e.getY();</span><br><span class="line">		} <span class="keyword">else</span> <span class="keyword">if</span>(ncount==<span class="number">2</span>){</span><br><span class="line">			x4 = e.getX();</span><br><span class="line">			y4 = e.getY();</span><br><span class="line">			graw.drawLine(x3, y3, x4, y4);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (ncount&gt;<span class="number">2</span>){</span><br><span class="line">			nx1=e.getX();</span><br><span class="line">			ny1=e.getY();</span><br><span class="line">			graw.drawLine(nx1, ny1, x4, y4);</span><br><span class="line">			x4=nx1;</span><br><span class="line">			y4=ny1;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (e.getClickCount()==<span class="number">2</span>){</span><br><span class="line">			nx2=e.getX();</span><br><span class="line">			ny2=e.getY();</span><br><span class="line">			graw.drawLine(x4,y4, nx2, ny2);</span><br><span class="line">			graw.drawLine(nx2, ny2, x3, y3);</span><br><span class="line">			ncount=<span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mousePressed</span><span class="params">(MouseEvent e)</span> {</span><br><span class="line">	x1 = e.getX();</span><br><span class="line">	y1 = e.getY();</span><br><span class="line">	System.out.println(<span class="string">"按下"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseReleased</span><span class="params">(MouseEvent e)</span> {</span><br><span class="line">	x2 = e.getX();</span><br><span class="line">	y2 = e.getY();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sbtn.equals(<span class="string">"直线"</span>)) {</span><br><span class="line">		graw.drawLine(x1, y1, x2, y2);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sbtn.equals(<span class="string">"矩形"</span>)) {</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (x2 &gt;= x1) {</span><br><span class="line">			graw.drawRect(x1, y1, Math.abs(x2 - x1), Math.abs(y2 - y1));</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			graw.drawRect(x2, y2, Math.abs(x2 - x1), Math.abs(y2 - y1));</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sbtn.equals(<span class="string">"圆形"</span>)) {</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (x2 &gt;= x1) {</span><br><span class="line">			graw.drawOval(x1, y1, Math.abs(x2 - x1), Math.abs(y2 - y1));</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			graw.drawOval(x2, y2, Math.abs(x2 - x1), Math.abs(y2 - y1));</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">"松开"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseEntered</span><span class="params">(MouseEvent e)</span> {</span><br><span class="line">	System.out.println(<span class="string">"进入"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseExited</span><span class="params">(MouseEvent e)</span> {</span><br><span class="line">	System.out.println(<span class="string">"离开"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这其中鼠标监听器中的方法大家可以自行查看，具体方法为高亮<code>MouseListener</code>后同时按下Ctrl+鼠标左键。这其中有几点要注意：</p>
<ul>
<li><p>注意点的坐标，选择恰当绘图的起点，不然画出来的图形会“乱跑”。</p>
</li>
<li><pre><code>         if (sbtn.equals("自选色")){
     Color c2 = JColorChooser.showDialog(null, "颜色提取器", Color.LIGHT_GRAY);
     graw.setColor(c2);
     JButton ccl=(JButton) e.getSource();
     ccl.setBackground(c2);		
 }
 <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">	</span><br><span class="line">	我们引用了Java的颜色提取器，它会在我们选定颜色后将按钮染成我们选定的颜色。注意，JColorChooser.showDialog（Component，String， Color— initialColor）的返回值为颜色，我们将其赋给变量C2。</span><br><span class="line">```java</span><br><span class="line">	DrawListener drl=new DrawListener();</span><br><span class="line">	jpc.addMouseListener(drl);</span><br><span class="line">	......</span><br><span class="line">	Graphics g=jpc.getGraphics(); </span><br><span class="line">	drl.graw=g;</span><br></pre></td></tr></tbody></table></figure>
最后，我们将图像绘制在CENTER面板中，这样我们就可以用它来画一些简易的图象了！
&lt;img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191023194128824.png" alt="在这里插入图片描述" style="zoom:67%"&gt;
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Fractals and Chaos | 分形与混沌</title>
    <url>/2020/01/02/%E5%88%86%E5%BD%A2%E4%B8%8E%E6%B7%B7%E6%B2%8C%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="分形与混沌（Chapter-2）"><a href="#分形与混沌（Chapter-2）" class="headerlink" title="分形与混沌（Chapter 2）"></a>分形与混沌（Chapter 2）</h1><p>笔者在上一篇博客中简单地介绍了几种分形体，现在就让我们试着在Java环境中实现一些简单的分形体。</p>
<h3 id="简单IFS（Iterated-Functions-Systems-）分形"><a href="#简单IFS（Iterated-Functions-Systems-）分形" class="headerlink" title="简单IFS（Iterated Functions Systems ）分形"></a>简单IFS（Iterated Functions Systems ）分形</h3><p>一如既往，我们首先实现一个界面及其监听器来方便我们画图。读者如果不了解具体方法可参照笔者之前的博客，这里不再赘述。</p>
<span id="more"></span>

<p>我们先来画一个简单的球形：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">1.7</span>, b = -<span class="number">2</span>, c = -<span class="number">2</span>, d = -<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) {</span><br><span class="line">			x = d * Math.sin(a * x) - Math.sin(b * y);</span><br><span class="line">			y = c * Math.cos(a * x) + Math.cos(b * y);</span><br><span class="line">			<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (<span class="type">int</span>) ((d * Math.sin(a * x) - Math.sin(b * y)) * <span class="number">100</span> + <span class="number">400</span>);</span><br><span class="line">			<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) ((c * Math.cos(a * x) + Math.cos(b * y)) * <span class="number">100</span> + <span class="number">400</span>);</span><br><span class="line">			gr.drawLine(m, n, m, n);</span><br><span class="line">			gr.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">250</span>, i % <span class="number">255</span>, i % <span class="number">155</span>));</span><br><span class="line">		}</span><br></pre></td></tr></tbody></table></figure>
<p>代码中的 a、b、c、d 为我们拟定的参数，它们决定了整个分形图形的形状。我们将参数代入公式，用 for循环 来实现100000次的递归，每递归一次画一个点。 要注意的是，画在JFrame上的点应为整数，所以我们在画之前须将坐标 m、n 强制转型为整型。<br><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191112221239493.png" alt="在这里插入图片描述"><br>如果我们将参数稍加修改（double a = -2, b =-30, c = -1.9, d = 1.9;）则有：</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191112223427439.png" alt="在这里插入图片描述">

<p>类似地，还有：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0f</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0f</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">1.7</span>, b = <span class="number">1.8</span>, c = -<span class="number">1.9</span>, d = <span class="number">0.4</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">255000</span>; i++) {</span><br><span class="line">		<span class="type">double</span> <span class="variable">temx</span> <span class="operator">=</span> Math.sin(a * y) + c * Math.cos(a * x);</span><br><span class="line">		<span class="type">double</span> <span class="variable">temy</span> <span class="operator">=</span> Math.sin(b * x) + d * Math.cos(b * y);</span><br><span class="line">		<span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> (<span class="type">int</span>) (temx * <span class="number">130</span> + <span class="number">400</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">y1</span> <span class="operator">=</span> (<span class="type">int</span>) (temy * <span class="number">130</span> + <span class="number">400</span>);</span><br><span class="line">		gr.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">100</span>, i % <span class="number">255</span>, i % <span class="number">155</span>));</span><br><span class="line">		gr.drawLine(x1, y1, x1, y1);</span><br><span class="line">		x = temx;	y = temy;</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/2019111222440965.png" alt="在这里插入图片描述">

<p>是不是很神奇呢？ 读者可以自己尝试着修改参数。期待你们的作品哦。</p>
<h3 id="随机参数画法（Gallery-of-Randomly-Generated-IFS）"><a href="#随机参数画法（Gallery-of-Randomly-Generated-IFS）" class="headerlink" title="随机参数画法（Gallery of Randomly Generated IFS）"></a>随机参数画法（Gallery of Randomly Generated IFS）</h3><p>这里的实现思路基本与简单IFS相同。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> rda[] = { <span class="number">0.1400</span>, <span class="number">0.4300</span>, <span class="number">0.4500</span>, <span class="number">0.4900</span> };</span><br><span class="line"><span class="type">double</span> rdb[] = { <span class="number">0.0100</span>, <span class="number">0.5200</span>, -<span class="number">0.4900</span>, <span class="number">0.0000</span> };</span><br><span class="line"><span class="type">double</span> rdc[] = { <span class="number">0.0000</span>, -<span class="number">0.4500</span>, <span class="number">0.4700</span>, <span class="number">0.0000</span> };</span><br><span class="line"><span class="type">double</span> rdd[] = { <span class="number">0.5100</span>, <span class="number">0.5000</span>, <span class="number">0.4700</span>, <span class="number">0.5100</span> };</span><br><span class="line"><span class="type">double</span> rde[] = { -<span class="number">0.0800</span>, <span class="number">1.4900</span>, -<span class="number">1.6200</span>, <span class="number">0.0200</span> };</span><br><span class="line"><span class="type">double</span> rdf[] = { -<span class="number">1.3100</span>, -<span class="number">0.7500</span>, -<span class="number">0.7400</span>, <span class="number">1.6200</span> };</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) {</span><br><span class="line">		<span class="type">Random</span> <span class="variable">ran</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">		<span class="type">int</span> <span class="variable">rr</span> <span class="operator">=</span> ran.nextInt(<span class="number">4</span>);</span><br><span class="line">		<span class="type">double</span> <span class="variable">temx</span> <span class="operator">=</span> rda[rr] * x + rdb[rr] * y + rde[rr];</span><br><span class="line">		<span class="type">double</span> <span class="variable">temy</span> <span class="operator">=</span> rdc[rr] * x + rdd[rr] * y + rdf[rr];</span><br><span class="line">		<span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> (<span class="type">int</span>) (temx * <span class="number">100</span> + <span class="number">400</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">y1</span> <span class="operator">=</span> (<span class="type">int</span>) (temy * <span class="number">100</span> + <span class="number">400</span>);</span><br><span class="line">		gr.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">224</span>,<span class="number">76</span>,<span class="number">49</span>));</span><br><span class="line">		gr.drawLine(x1, y1, x1, y1);</span><br><span class="line">		x = temx; y = temy;</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>
<p>要注意的是，这里需要运用随机数组，每组参数（a、b、c、d ）的值如代码中展示。我们运用随机数<code>Random ran = new Random();             int rr = ran.nextInt(4);</code>来锚定每次选取哪一组参数。执行结果如下：</p>
<p>如图所示，我们得到了一个IFS枫叶。在这里，分形图形的自相似性质就非常明显了。照此思路，我们尝试修改参数：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">double</span> rda[] = { <span class="number">0.0000</span> ,<span class="number">0.7248</span> ,<span class="number">0.1583</span> , <span class="number">0.3386</span> };</span><br><span class="line"><span class="type">double</span> rdb[] = { <span class="number">0.2439</span> , <span class="number">0.0337</span> , -<span class="number">0.1297</span>, <span class="number">0.3694</span> };</span><br><span class="line"><span class="type">double</span> rdc[] = { <span class="number">0.0000</span> , -<span class="number">0.0253</span> , <span class="number">0.3550</span>, <span class="number">0.2227</span> };</span><br><span class="line"><span class="type">double</span> rdd[] = { <span class="number">0.3053</span>, <span class="number">0.7426</span>, <span class="number">0.3676</span> , -<span class="number">0.0756</span> };</span><br><span class="line"><span class="type">double</span> rde[] = { <span class="number">0.0000</span>, <span class="number">0.2060</span>, <span class="number">0.1383</span>, <span class="number">0.0679</span> };</span><br><span class="line"><span class="type">double</span> rdf[] = { <span class="number">0.0000</span>, <span class="number">0.2538</span>, <span class="number">0.1750</span>, <span class="number">0.0826</span> };</span><br></pre></td></tr></tbody></table></figure>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191112234451607.png" alt="在这里插入图片描述">

<p>再比如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> rda[] = { <span class="number">0.2020</span>, <span class="number">0.1380</span> };</span><br><span class="line"><span class="type">double</span> rdb[] = { -<span class="number">0.8050</span>, <span class="number">0.6650</span> };</span><br><span class="line"><span class="type">double</span> rdc[] = { -<span class="number">0.6890</span>, -<span class="number">0.5020</span> };</span><br><span class="line"><span class="type">double</span> rdd[] = { -<span class="number">0.3420</span>, -<span class="number">0.2220</span> };</span><br><span class="line"><span class="type">double</span> rde[] = { -<span class="number">0.3730</span>, <span class="number">0.6600</span> };</span><br><span class="line"><span class="type">double</span> rdf[] = { -<span class="number">0.6530</span>, -<span class="number">0.2770</span> };</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) {</span><br><span class="line">		<span class="type">Random</span> <span class="variable">ran</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">		<span class="type">int</span> <span class="variable">rr</span> <span class="operator">=</span> ran.nextInt(<span class="number">2</span>);</span><br><span class="line">		<span class="type">double</span> <span class="variable">temx</span> <span class="operator">=</span> rda[rr] * x + rdb[rr] * y + rde[rr];</span><br><span class="line">		<span class="type">double</span> <span class="variable">temy</span> <span class="operator">=</span> rdc[rr] * x + rdd[rr] * y + rdf[rr];</span><br><span class="line">		<span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> (<span class="type">int</span>) (temx * <span class="number">550</span> + <span class="number">330</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">y1</span> <span class="operator">=</span> (<span class="type">int</span>) (temy * <span class="number">550</span> + <span class="number">670</span>);</span><br><span class="line">		gr.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">250</span>, i % <span class="number">255</span>, i % <span class="number">155</span>));</span><br><span class="line">		gr.drawLine(x1, y1, x1, y1);</span><br><span class="line">		x = temx;  y = temy;</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191112232153553.png" alt="在这里插入图片描述">

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>IFS分形是分形学科重要的分支之一。它的算法相对简单，但却依然能绘制出瑰丽的图形，体现着几何之美。探索之路，永无止境，分形还有着无穷的秘密等待我们去发掘。IFS分形还可以用来实现一些缓冲动画与空间矩阵，在以后的博客中，笔者会一一为读者介绍 。下篇博客将会介绍一些简单的谢尔宾斯基（Sierpinski）分形，敬请期待。</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191112234008944.png" alt="在这里插入图片描述">]]></content>
      <categories>
        <category>Vision</category>
      </categories>
  </entry>
  <entry>
    <title>Java实现界面及事件监听</title>
    <url>/2019/12/03/Java%E7%9A%84%E7%95%8C%E9%9D%A2%E5%8F%8A%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/</url>
    <content><![CDATA[<h2 id="Java的界面及事件的监听"><a href="#Java的界面及事件的监听" class="headerlink" title="Java的界面及事件的监听"></a>Java的界面及事件的监听</h2><p><strong>创建界面</strong></p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191013193438351.png" alt="一个简单的登录界面">

<p>如上图所示，这就是一个在Java环境下实现的简单界面。此界面包括标题、图片、账号密码输入框、记住密码和自动登录自选框以及登录按钮。</p>
<span id="more"></span>

<p>要实现这样一个界面，首先要导入一个用于界面开发的类别：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">`<span class="keyword">import</span> javax.swing.JFrame;`</span><br></pre></td></tr></tbody></table></figure>
<p>这样，我们才可以定义一个JFrame变量：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">JFrame</span> <span class="variable">jf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>定义界面变量之后我们就可以对这个界面进行一定的修饰：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">jf.setTitle(<span class="string">"欢迎登录"</span>);</span><br><span class="line">jf.setSize(<span class="number">400</span>,<span class="number">370</span>); </span><br><span class="line">jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">jf.setLocationRelativeTo(<span class="literal">null</span>);</span><br><span class="line">jf.setResizable(<span class="literal">false</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>这几行代码分别设定了界面的标题、大小尺寸、关闭按钮和组件排布方式以及设定不能改变界面大小，其中组件排布方式为局中。<br><img src="raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191013203456752.png" alt="在这里插入图片描述"><br>这样我们就实现了一个指定大小的界面。需要注意的是，记得给程序添加关闭按钮，即用<code>jf.setDefaultCloseOperation( );</code>来实现，括号内填写   JFrame.EXIT_ON_CLOSE 或 3 ，这两个式子是等价的。<br><strong>修饰界面</strong><br>创建了界面之后，我们就可以就可以对其进行修饰。首先我们定义组件的排列方式为流式排列：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">FlowLayout fl=<span class="keyword">new</span> <span class="title class_">FlowLayout</span>();</span><br><span class="line">	jf.setLayout(fl);</span><br></pre></td></tr></tbody></table></figure>
<p>其次，我们创建一系列组件：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   ImageIcon image=<span class="keyword">new</span> <span class="title class_">ImageIcon</span>(<span class="string">"C:\\Users\\15593\\Pictures\\Saved Pictures\\bg1.jpg"</span>);</span><br><span class="line">JLabel imagela=<span class="keyword">new</span> <span class="title class_">JLabel</span>(image);</span><br><span class="line">JLabel name=<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">"账号"</span>);</span><br><span class="line"><span class="type">JLabel</span> <span class="variable">password</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">"密码"</span>);</span><br><span class="line">	</span><br><span class="line">JTextField namein=<span class="keyword">new</span> <span class="title class_">JTextField</span>();</span><br><span class="line">JPasswordField passin=<span class="keyword">new</span> <span class="title class_">JPasswordField</span>();</span><br><span class="line">JButton btn=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"登录"</span>);</span><br><span class="line">JCheckBox check1=<span class="keyword">new</span> <span class="title class_">JCheckBox</span>(<span class="string">"记住密码"</span>);</span><br><span class="line">JCheckBox check2=<span class="keyword">new</span> <span class="title class_">JCheckBox</span>(<span class="string">"自动登录"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>而要创建这些组件，我们也要事先导入这些组件的包：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Dimension;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JCheckBox;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPasswordField;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JTextField;</span><br></pre></td></tr></tbody></table></figure>
<p>其中，引用的图片可以是储存在电脑中时的路径名，也可以是放在Project中的图像名。让我们对按钮进行一定的修饰：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Dimension dim=<span class="keyword">new</span> <span class="title class_">Dimension</span>(<span class="number">330</span>,<span class="number">30</span>);</span><br><span class="line">btn.setBackground(Color.WHITE);</span><br><span class="line">namein.setPreferredSize(dim);</span><br><span class="line">passin.setPreferredSize(dim);</span><br></pre></td></tr></tbody></table></figure>
<p>这几行代码分别规定了按钮的背景颜色和两个输入文本框的大小。但要记得，创建完组件后要将组件添加到界面里：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">jf.add(imagela);</span><br><span class="line">jf.add(name);</span><br><span class="line">jf.add(namein);</span><br><span class="line">jf.add(password);</span><br><span class="line">jf.add(passin);</span><br><span class="line">jf.add(check1);</span><br><span class="line">jf.add(check2);</span><br><span class="line">jf.add(btn);</span><br><span class="line">jf.setVisible(<span class="literal">true</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>记得一定要记得写最后一行代码，不然界面会一闪而过！</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/0191013210828606.png" alt="在这里插入图片描述">

<p>一个界面就这样成功实现了。<br><strong>事件监听</strong><br>实现了界面之后，我们就要实现一定界面的功能。于是我们创建监听器，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 界面;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JTextField;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span>{</span><br><span class="line"></span><br><span class="line">	JTextField nametx;</span><br><span class="line">	JTextField passtx;</span><br><span class="line">	JFrame jf;</span><br><span class="line">	Pad3DBall pad3dball;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> {</span><br><span class="line">		</span><br><span class="line">		 <span class="type">String</span> <span class="variable">nameString</span> <span class="operator">=</span> nametx.getText();</span><br><span class="line">		 <span class="type">String</span> <span class="variable">passString</span> <span class="operator">=</span> passtx.getText();</span><br><span class="line">		 </span><br><span class="line">		 <span class="keyword">if</span> (passString.equals(<span class="string">""</span>)) {</span><br><span class="line">					System.out.println(<span class="string">"请输入密码"</span>);</span><br><span class="line">		 }<span class="keyword">else</span> {</span><br><span class="line">			 </span><br><span class="line">		 <span class="keyword">if</span> (nameString.equals(<span class="string">"123456"</span>)&amp;&amp;passString.equals(<span class="string">"456789"</span>)) {</span><br><span class="line">					System.out.println(<span class="string">"账号正确"</span>);</span><br><span class="line">					jf.setVisible(<span class="literal">false</span>);</span><br><span class="line">					<span class="type">Pad3DBall</span> <span class="variable">pad3dball</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pad3DBall</span>();</span><br><span class="line">					pad3dball.intUI();</span><br><span class="line">		 }<span class="keyword">else</span> {</span><br><span class="line">					System.out.println(<span class="string">"账号输入错误"</span>);</span><br><span class="line">		 }</span><br><span class="line">			 </span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们用一个类去实现接口，即 implements<br>其格式：public class 类名 implements 接口名{ } ，其中不能创建带有具体方法体的方法，因此我们需要将方法后的大括号改为分号，化具体为抽象：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   JTextField nametx;</span><br><span class="line">JTextField passtx;</span><br><span class="line">JFrame jf;</span><br><span class="line">Pad3DBall pad3dball;</span><br></pre></td></tr></tbody></table></figure>
<p>之后我们重载监听器接口的抽象方法</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> {</span><br><span class="line">		</span><br><span class="line">		 <span class="type">String</span> <span class="variable">nameString</span> <span class="operator">=</span> nametx.getText();</span><br><span class="line">		 <span class="type">String</span> <span class="variable">passString</span> <span class="operator">=</span> passtx.getText();</span><br><span class="line">		 </span><br><span class="line">		 <span class="keyword">if</span> (passString.equals(<span class="string">""</span>)) {</span><br><span class="line">					System.out.println(<span class="string">"请输入密码"</span>);</span><br><span class="line">		 }<span class="keyword">else</span> {</span><br><span class="line">			 </span><br><span class="line">		 <span class="keyword">if</span> (nameString.equals(<span class="string">"123456"</span>)&amp;&amp;passString.equals(<span class="string">"456789"</span>)) {</span><br><span class="line">					System.out.println(<span class="string">"账号正确"</span>);</span><br><span class="line">					jf.setVisible(<span class="literal">false</span>);</span><br><span class="line">					<span class="type">Pad3DBall</span> <span class="variable">pad3dball</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pad3DBall</span>();</span><br><span class="line">					pad3dball.intUI();</span><br><span class="line">		 }<span class="keyword">else</span> {</span><br><span class="line">					System.out.println(<span class="string">"账号输入错误"</span>);</span><br><span class="line">		 }</span><br><span class="line">			 </span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>
<p>在这些方法中，我们首先提取了账户密码输入框中用户输入的字符串，将其跟我们既定的数据进行比较，用<code>equals("......")</code>来实现，输入正确后，按下登录按钮就可以执行我们既定的程序了。 其中，<code>jf.setVisible(false);</code>关闭了登录界面，而<code>Pad3DBall pad3dball = new Pad3DBall();                     pad3dball.intUI();</code>则执行绘制了一个图像，这里代码从略。<br>最后，我们将监听器应用到我们的主程序中，在按下按钮（btn）后执行：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">LoginListener</span> <span class="variable">nll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginListener</span>();</span><br><span class="line">btn.addActionListener(nll);</span><br><span class="line">nll.passtx=passin;</span><br><span class="line">nll.nametx=namein;</span><br><span class="line">nll.jf=jf;</span><br></pre></td></tr></tbody></table></figure>
<p>我们正确输入账户密码后按下“登录”，执行结果如下：</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/0191013214124480.png" alt="在这里插入图片描述" style="zoom:67%;">

<p>以上就是简单的界面实现及事件的监听方法了。<br>感谢观看！</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Fractals and Chaos | 分形与混沌</title>
    <url>/2019/11/13/%E5%88%86%E5%BD%A2%E4%B8%8E%E6%B7%B7%E6%B2%8C%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="分形与混沌（Chapter-1）"><a href="#分形与混沌（Chapter-1）" class="headerlink" title="分形与混沌（Chapter 1）"></a>分形与混沌（Chapter 1）</h2><h3 id="分形概述"><a href="#分形概述" class="headerlink" title="分形概述"></a>分形概述</h3><p>分形（英语：fractal，源自拉丁语：frāctus，有“零碎”、“破裂”之意），又称碎形、残形，通常被定义为“一个粗糙或零碎的几何形状，可以分成数个部分，且每一部分都（至少近似地）是整体缩小后的形状”即具有自相似的性质。<br>分形在数学中是一种抽象的物体，用于描述自然界中存在的事物。而人工实现的分形通常在放大后能展现出相似的形状，因此分形也被称为扩展对称或展开对称。如果在每次放缩（递归）后，图形形状的重复是完全相同的，这就被称为自相似。自相似的典型例子如门格海绵：</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191110224110830.png" style="zoom:67%;">

<span id="more"></span>

<p>如图所示，这就是一个递归了5次的 门格海绵，它的每一个单元都是自相似的。</p>
<p>分形图像自身细节的重复意味分形与其他几何图形相似但又有所不同。当你放缩一个图形时，你就能看出分形和其他几何图形的区别：</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191110225356770.png" style="zoom:67%;">

<p>如果将分形的一维长度加倍，分型空间填充变为 2的n次方 倍，但此时n 不一定是个整数，指数 n 称为分型的维数。</p>
<p>作为一个数学函数，分形通常是处处不可微的。无穷分形曲线可以理解为一条一维的曲线在空间中绕行，它的拓扑维数仍然是 1，但大于 1 的分形维数暗示了它有着类似曲面的性质。</p>
<p>总之，分形作为一个重要的数学分支，从17世纪被提出至今，有着庞大而复杂的学术体系与应用方向，这里不再赘述。感兴趣的读者可以去维基百科自行查阅。</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191110233504839.png" style="zoom:80%;">

<h3 id="分形——解构世界的算法"><a href="#分形——解构世界的算法" class="headerlink" title="分形——解构世界的算法"></a>分形——解构世界的算法</h3><p>如图所示，根据分形原理，如果将一棵树的树杈不断缩放，去观察局部，那么自相似的性质就非常明显了。</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/image-20231103101111097.png" style="zoom:80%">

<img src="//raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/image-20231103101345938.png" alt="image-20231103101345938" style="zoom:67%;">

<p>再比如说斐波那契螺旋线分形：</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191110233618887.png" style="zoom:90%;">

<p float="left">   
    <img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191110233637623.png">   
    <img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191110233556785.png">
</p>

<p>混沌之谜–逻辑斯蒂方程</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191110234403456.png" style="zoom:80%">

<h3 id="分形举例"><a href="#分形举例" class="headerlink" title="分形举例"></a>分形举例</h3><h4 id="噪声："><a href="#噪声：" class="headerlink" title="噪声："></a>噪声：</h4><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/image-20231103101448413.png" alt="image-20231103101448413" style="zoom:67%;">

<h4 id="多面体："><a href="#多面体：" class="headerlink" title="多面体："></a>多面体：</h4><p>帕斯卡三角形  &amp; 塞尔宾斯基堆</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/201911102356059.png" alt="image-20231103101550473" style="zoom:67%;">

<p>塞尔宾斯基地毯</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191110235850975.png">



<p> 除此之外还有门格海绵、开普勒多面体等。</p>
<h4 id="IFS分形"><a href="#IFS分形" class="headerlink" title="IFS分形"></a>IFS分形</h4><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/image-20231103101646775.png" alt="image-20231103101646775" style="zoom:80%;"> 

<p>还有类似于上文的 枫叶 也属于IFS分形。</p>
<h4 id="L-系统"><a href="#L-系统" class="headerlink" title="L-系统"></a>L-系统</h4><p> 这个类型的分形常用来实现类似上文中植物的分形。这里因为篇幅不再举例。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p> 分形的种类繁多，瑰丽而奇异。这其中蕴含这无数数学家与程序员的智慧。笔者才疏学浅，即使绞尽脑汁，也仅能勘知一二。一个分形体既可以仅仅是一条1.26维的线段，也可以是绚丽的3D效果（如光线追踪）。本篇博客简单介绍了分形的一些概念即其种类，笔者会在接下来的博客中详细介绍用Java语言实现几种简单分形体的具体方法，不定期更新，敬请关注哦。</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191111002040693.png" style="zoom:80%">

]]></content>
      <categories>
        <category>Vision</category>
      </categories>
  </entry>
  <entry>
    <title>Fundamental Sorting | 基本排序算法</title>
    <url>/2018/12/07/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>排序就是将给定数据按照一定的顺序（升序或降序）重新排列。 排序是许多算法的基础，可以让数据变得容易处理。<br>排序时，需要先确定排序的基准，即“排序键”；在选择排序算法时，<strong>时间复杂度、空间复杂度</strong> 和 <strong>稳定排序</strong> 都是重要的考量标准。 所谓稳定排序，即指在数据中含有键值相等的元素，其在排序完成后顺序不变。<br>时至今日，人们已经开发出了许多种排序方法，其机制个不相同。 我们要根据实际情况，选择适宜的排序方法：</p>
<ul>
<li><strong>复杂度与稳定性</strong></li>
<li>除了原有数据外是否还需要<strong>额外的内存</strong></li>
<li><strong>输入数据的特征</strong>可能会影响算法的效率</li>
</ul>
<p> 虽然各种编程语言的库中都有标准排序算法供我们使用，但是，算法乃是程序员的自我修养，而排序是算法的基础，深入理解其原理可以为我们将来实现其他功能提供思路与方法。</p>
<span id="more"></span>

<h3 id="初等排序"><a href="#初等排序" class="headerlink" title="初等排序"></a>初等排序</h3><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>插入排序将待排序数据分为 已排序 和 未排序 部分，取出未排序部分的开头元素，将它的值储存在临时变量v里，然后<strong>将所有比v大的元素都后移一位</strong>，再将v插入到空位里。这就是插入排序了，很简单吧，我们直接上代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertsort</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> arr[])</span> </span>{</span><br><span class="line">	<span class="type">int</span> v, j;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) { <span class="comment">// 假设设第一个[0]元素已经排好，从1开始循环</span></span><br><span class="line">		v = arr[i]; <span class="comment">// 以v作为比较基准，即未排序部分的开头元素值</span></span><br><span class="line">		j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 进行移动，将所有大于v的元素后移一个单位</span></span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; v) { <span class="comment">// 注意循环条件</span></span><br><span class="line">			arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">			j--;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// 最后将v插入在恰当位置，即所有小于等于v的元素之前</span></span><br><span class="line">		arr[j + <span class="number">1</span>] = v; <span class="comment">// 注意：寻找到插入位置后仍然会执行 j--</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>分析插入排序的特征，我们可以发现，因为插入排序不会直接交换不相邻的元素，而是将所有比当前元素键值大的元素后移，因此，插入排序是稳定的。<br>再看看复杂度，在<strong>最极端的条件下</strong>，我们需要将 每个i循环 进行i次移动，总共需要1+2+……+N-1=(N^2 -N)次移动，当N很大时，我们可以忽略N的项而保留 N平方 的项，即插入排序的时间复杂度O(N*N)。但是如果是已经按照升序排列好的数组，我们只需要N次比较就可以完成排序。 由此可见，输入数据的特征可以明显影响排序的效率。亦可以看出，<strong>插入排序能够快速处理相对有序的数据</strong>，这一点很重要，在高等排序的 希尔排序 中会对这一特性进行扩展。</p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序实现简单，使用广泛。它的机制是依次比较相邻元素，将所有大小关系相反的数据交换：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span>* q)</span> </span>{</span><br><span class="line">	<span class="type">int</span> tem = *p;</span><br><span class="line">	*p = *q;</span><br><span class="line">	*q = tem;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 冒泡排序算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bubblesort</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> arr[])</span> </span>{</span><br><span class="line">	<span class="type">int</span> times = <span class="number">0</span>;</span><br><span class="line">	<span class="type">bool</span> flag = <span class="number">1</span>;			   <span class="comment">// 发挥外层变量i的作用</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;flag;i++) { <span class="comment">// 已经排序完成的前i个元素不需要再次进行比较</span></span><br><span class="line">		flag = <span class="number">0</span>;			   <span class="comment">// 每次需比较至i+1</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>;j &gt;= i + <span class="number">1</span>;j--) { <span class="comment">// 从数组末尾开始循环防止溢出</span></span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) {</span><br><span class="line">				<span class="built_in">swap</span>(arr[j], arr[j - <span class="number">1</span>]);</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">				times++;</span><br><span class="line">			}</span><br><span class="line">		} <span class="comment">// 当某一次循环中不发生交换时则证明已经排序完成</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> times; <span class="comment">// 返回交换次数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>类似的，我们对冒泡排序算法进行分析，其在最坏的情况下需要（N^2 -N）次比较，即算法时间复杂度为O(N*N)。顺带一提，函数返回的交换次数也称为逆序数，反应了数据的混乱程度。</p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>同样的，选择排序也将数组分为 已排序 和 未排序 的部分。 找出未排序部分的最小(大)值的位置下标 min_j (max_j)，将min_j 位置的元素与未排序部分的开头元素交换，重复N-1次(N个元素，最多换N-1次)：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 选择排序算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">selectionsort</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> arr[])</span> </span>{</span><br><span class="line">	<span class="type">int</span> times, min_j;</span><br><span class="line">	times = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++) { <span class="comment">// i表示未排序部分的开头元素下标</span></span><br><span class="line">		min_j = i; <span class="comment">// min_j 表示每轮循环中 第i 到 第N-1 元素中 最小值的下标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i;j &lt; n;j++) { <span class="comment">// 更新最小值下标</span></span><br><span class="line">			<span class="keyword">if</span> (arr[min_j] &gt; arr[j]) min_j = j;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">swap</span>(arr[i], arr[min_j]);</span><br><span class="line">		<span class="keyword">if</span> (i != min_j) times++; <span class="comment">// 若最小值为arr[i]本身则无需交换</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> times;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>要注意的是，选择排序会<strong>交换不相邻的元素</strong>，因此可能出现排序键值相等而元素顺序改变的情况，例如：数组{3H,5L,3D,1S}，在对 数字键值 执行选择排序后，会变成{1S,3D,3H,5L} （大家可以自行验证）。可见，<strong>选择排序是不稳定的</strong>。<br>再来看看复杂度，无论在什么情况下，选择排序都要进行（N^2-N）/2 次比较运算，复杂度与N*N成正比。</p>
<h4 id="初等排序小结"><a href="#初等排序小结" class="headerlink" title="初等排序小结"></a>初等排序小结</h4><p>综合来观察三种初等排序方法。冒泡排序从局部出发，逐项比较，减少逆序数；选择排序面向整体，逐个选择最小（大）值。虽然这二者思路大相径庭，但是我们可以看出，冒泡排序 和 选择排序 不依赖输入数据。而与之相对的，插入算法却很依赖数据，处理相对有序的数据有很高的效率。</p>
<h3 id="高等排序"><a href="#高等排序" class="headerlink" title="高等排序"></a>高等排序</h3><p>虽然初等排序在应对一般数据时已经有很好的效果，但是在非常庞大的数据面前便会失去效果。因此，我们就需要运用高等排序。 高等排序是通过运用 <strong>分治法与递归法</strong>，结合初等排序思路 进行优化而实现的高速算法。</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>上文提到过，插入排序 在针对相对有序的数据时具有非常高的效率。而 希尔排序就是针对这一特性而实现的高速算法。<br>希尔排序的思路是，<strong>重复进行以间隔为g的插入排序，g的值逐轮减小，最后再执行 间隔g=1 的一般插入排序</strong>。 为什么要进行这样的操作呢？<br>其实，每一轮以g为间隔时，其实都是把选出来的数据组成一个新的数组，这些数组的元素数目N’相对N来讲很小。第一轮时，g1约为数据量N的1/3~ 1/2 ，这些分割出来的数组只有2~3个元素，进行排序非常快捷。第二轮时，经过第一轮的处理，此时的数组相对原数组变得相对有序了一些（好吧，虽然只有一点点，(⊙o⊙)），此时，间隔g2减小，继续执行排序，这些小数组又变得有序了。 继续一轮轮的执行这些操作，间隔g逐渐减小；<strong>每一轮操作时，因为之前的插入排序，对数据整体来说，此时的数组已经变得相对有序了很多</strong>。所以此时在执行当前g的插入排序，效率比直接执行此gap的插入排序提高了非常多。<br>根据这个原理，<strong>最后在执行 g=1 的插入排序时，因为数据已经变得非常有序了，此时的排序效率非常高</strong>。<br>那么，由此可见，希尔排序的效率就跟Gap间隔数组的选择有很大的关系，根据数学原理，当递推关系式为：g(n+1) = 3*g(n)+1 时，希尔排序的复杂度基本稳定在O(N^1.25)。具体数学原理本文就不做讨论了（才不是因为论文太难看不懂呢😂）。但要注意的是，如果Gap间隔数组为2的幂指数，则算法的效率会大打折扣。代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionsort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> g)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellsort</span><span class="params">(<span class="type">int</span> arr[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> cnt;</span><br><span class="line"><span class="type">int</span> arr[LEN];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; Gap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; LEN;i++) {</span><br><span class="line">		arr[i] = <span class="built_in">rand</span>() % <span class="number">10000</span> + <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; LEN;i++) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%6d"</span>, arr[i]);</span><br><span class="line">		<span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="built_in">shellsort</span>(arr);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; LEN;i++) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%6d"</span>, arr[i]);</span><br><span class="line">		<span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>, cnt);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// ShellSort算法核心</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionsort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> g)</span> </span>{ <span class="comment">// 指定gap的插入排序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = g;i &lt; LEN;i++) {</span><br><span class="line">		<span class="type">int</span> v = arr[i];</span><br><span class="line">		<span class="type">int</span> j = i - g;</span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; v) {</span><br><span class="line">			arr[j + g] = arr[j];</span><br><span class="line">			j -= g;</span><br><span class="line">			cnt++;</span><br><span class="line">		}</span><br><span class="line">		arr[j + g] = v;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellsort</span><span class="params">(<span class="type">int</span> arr[])</span> </span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">1</span>;;) { <span class="comment">// 递推公式生成Gap数组</span></span><br><span class="line">		<span class="keyword">if</span> (h &gt; LEN) <span class="keyword">break</span>;</span><br><span class="line">		Gap.<span class="built_in">push_back</span>(h);</span><br><span class="line">		h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = Gap.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) {</span><br><span class="line">		<span class="built_in">insertionsort</span>(arr, Gap[i]);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>类似于希尔排序，归并排序也是从局部入手，将庞大复杂的数据<strong>向下逐层拆分成小的局部数组</strong>，再进行<strong>逐层向上的整合</strong>，从而实现高速的排序。我们直接上代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> L[MAX / <span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> R[MAX / <span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 归并排序算法核心</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>{</span><br><span class="line">	<span class="type">int</span> n1 = mid - left;</span><br><span class="line">	<span class="type">int</span> n2 = right - mid;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n1;i++) L[i] = A[left + i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n2;i++) R[i] = A[mid + i];</span><br><span class="line">	L[n1] = R[n2] = SENTINAL;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="comment">// 注意合并方式！</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = left;k &lt; right;k++) {</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">if</span> (L[i] &lt;= R[j]) A[k] = L[i++];</span><br><span class="line">		<span class="keyword">else</span> A[k] = R[j++];</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>{</span><br><span class="line">	<span class="comment">// 分割至倒数第二层时 left=t, mid=t+1, right=t+2</span></span><br><span class="line">	<span class="comment">// 分割至最后一层，'局部数组'变成了单个元素</span></span><br><span class="line">	<span class="comment">// 最终形成'树'的结构</span></span><br><span class="line">	<span class="comment">// 此时 merge 的对象为两个单元素数组</span></span><br><span class="line">	<span class="keyword">if</span> (left + <span class="number">1</span> &lt; right) {</span><br><span class="line">		<span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">mergeSort</span>(A, n, left, mid);</span><br><span class="line">		<span class="built_in">mergeSort</span>(A, n, mid, right);</span><br><span class="line">		<span class="built_in">merge</span>(A, n, left, mid, right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>归并排序的核心是merge函数，逐层分割后的局部数组在merge函数的整合下，每一层的复杂度是O(n_left+n_right)<strong>，于是整个算法的复杂度为O(N*logN)。<br>我们容易看出，只要元素出现在其键值相等的其他元素之前，其在分割与整合后就一定在其他元素之前，所以归并排序是稳定的。<br>但要注意的是，虽然归并排序稳定高效，但是它却</strong>需要额外的内存来储存分割出来的临时数组，占据额外的空间</strong>。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序可以说是运用最为广泛的排序算法了，它稳定高效，C++的STL库函数sort( ) 就是基于快速排序的函数。 快速排序基于递归法，在分割的同时对数据进行排序与调换：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i, j, t, temp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	temp = randarr[left];</span><br><span class="line">	i = left;  j = right;</span><br><span class="line">	<span class="keyword">while</span> (i != j) {</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (randarr[j] &gt;= temp &amp;&amp; i &lt; j) j--; <span class="comment">// i循环</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (randarr[i] &lt;= temp &amp;&amp; i &lt; j) i++; <span class="comment">// j循环</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) {</span><br><span class="line">			t = randarr[i];</span><br><span class="line">			randarr[i] = randarr[j];</span><br><span class="line">			randarr[j] = t;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	randarr[left] = randarr[i];</span><br><span class="line">	randarr[i] = temp;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">quicksort</span>(left, i - <span class="number">1</span>);  <span class="comment">//左递归</span></span><br><span class="line">	<span class="built_in">quicksort</span>(i + <span class="number">1</span>, right); <span class="comment">//右递归</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>主函数调用时需要传递初始参数，即 quicksort(0,n-1)。 观察上述代码，i、j 即为所谓的标兵节点。<strong>第一轮</strong>调用时，i从0，j从n-1开始，<strong>选择 arr[0] 为比较基准，储存在temp中</strong>。<strong>i和j while循环中，i寻找比temp大的节点，j寻找比temp小的节点</strong>；i、j 不可错位(设置适宜的循环条件)。i和j 循环结束时，如果是因为i==j，则结束外层循环，进入下一步；而如果是因为找到了目标节点，则两个值互换，继续执行代码； 无论如何，<strong>只要外层while循环结束，i和j 相遇在同一节点</strong>，再将arr[left]的值换到i位置，<strong>此时 i(j) 之前的元素都小于等于temp，之后的元素都大于等于temp</strong>。 进行递归调用<code>quicksort(left, i - 1);  //左递归     quicksort(i + 1, right); //右递归</code>，即将左右分别再次执行一次上述操作，直到left=right(局部数组为单个元素)返回，此时，排序就完成了。<br>上述的只是快速排序基准选择的一个方式，还有很多根据实际情况的方式，但思路大体一致，本文不再赘述。</p>
<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>计数排序相对简单，它善于处理元素为正整数的情况，具有极高的效率，但是其元素的最大值具有限制，否则会导致栈溢出：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountingSort</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) {</span><br><span class="line">		C[A[i]]++; <span class="comment">// A 中每个元素出现次数</span></span><br><span class="line">	} </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= MAX;j++) {</span><br><span class="line">		C[j] = C[j] + C[j - <span class="number">1</span>]; <span class="comment">// 注意，因为A[i] 可能等于0 C的下标从0开始</span></span><br><span class="line">	} <span class="comment">// 算法核心，通过逐项求和 C[X]表示还有多少小于等于X的项，即该放到第几位</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) {</span><br><span class="line">		B[C[A[i]]] = A[i];</span><br><span class="line">		C[A[i]]--; <span class="comment">// 自减保证值相同项的放置</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>为了表达方便，A下标从0开始。<br>第一个for循环结束，<strong>C[k] 的值即为A中值为k的元素出现的次数</strong>。再把C逐项累加，那么此时<strong>C[k]的值就表示A值为k的元素放置于排序完成数组B中的位置</strong>，也表示<strong>A中包含几个小于等于K的元素</strong>。计数排序能在O(N+Max)的线性时间完成排序，效率可以说非常高了。</p>
<h3 id="打个总结"><a href="#打个总结" class="headerlink" title="打个总结"></a>打个总结</h3><p>以上就是常见的排序算法了，其实不难看出，没有最好的排序算法，只有最适宜的排序方法，我们要根据实际情况来选择使用算法。对其他算法也是一样，我们要因地制宜，在不同情形下选择最优解；有些时候可能没有现成的方法让我们直接使用，这时候就需要分析问题，解决问题的能力，站在前人们的肩膀上，用这些思路创新开发出合适的方法。<br>笔者虽然仔细核对过文中附如的代码，但是难免疏漏，有问题或建议欢迎留言，谢谢。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
</search>
