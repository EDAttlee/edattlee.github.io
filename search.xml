<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Greetings!</title>
    <url>/2023/11/02/Greetings/</url>
    <content><![CDATA[<h2 id="Thanks-for-visiting-my-blog"><a href="#Thanks-for-visiting-my-blog" class="headerlink" title="Thanks for visiting my blog"></a>Thanks for visiting my blog</h2><p>Here I exhibit some of my  projects and research, and books I love. I’m interested in Deep-Learning, Robotics and Psychology. The primary objective of this blog is to encapsulate the myriad of technical challenges and insights I encounter on my educational journey, thereby aiding others. Furthermore, it serves as a practical application of the Feynman Technique, enhancing my own capacity for knowledge dissemination.</p>
<p>Should there be any inaccuracies or aspects of the blog that elicit confusion, please do not hesitate to contact me via email at your earliest convenience.</p>
]]></content>
  </entry>
  <entry>
    <title>Java实现界面及事件监听</title>
    <url>/2023/11/03/Java%E7%9A%84%E7%95%8C%E9%9D%A2%E5%8F%8A%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/</url>
    <content><![CDATA[<h2 id="Java的界面及事件的监听"><a href="#Java的界面及事件的监听" class="headerlink" title="Java的界面及事件的监听"></a>Java的界面及事件的监听</h2><p><strong>创建界面</strong></p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191013193438351.png" alt="一个简单的登录界面">

<p>如上图所示，这就是一个在Java环境下实现的简单界面。此界面包括标题、图片、账号密码输入框、记住密码和自动登录自选框以及登录按钮。</p>
<span id="more"></span>

<p>要实现这样一个界面，首先要导入一个用于界面开发的类别：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">`<span class="keyword">import</span> javax.swing.JFrame;`</span><br></pre></td></tr></tbody></table></figure>
<p>这样，我们才可以定义一个JFrame变量：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">JFrame</span> <span class="variable">jf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>定义界面变量之后我们就可以对这个界面进行一定的修饰：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">jf.setTitle(<span class="string">"欢迎登录"</span>);</span><br><span class="line">jf.setSize(<span class="number">400</span>,<span class="number">370</span>); </span><br><span class="line">jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">jf.setLocationRelativeTo(<span class="literal">null</span>);</span><br><span class="line">jf.setResizable(<span class="literal">false</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>这几行代码分别设定了界面的标题、大小尺寸、关闭按钮和组件排布方式以及设定不能改变界面大小，其中组件排布方式为局中。<br><img src="raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191013203456752.png" alt="在这里插入图片描述"><br>这样我们就实现了一个指定大小的界面。需要注意的是，记得给程序添加关闭按钮，即用<code>jf.setDefaultCloseOperation( );</code>来实现，括号内填写   JFrame.EXIT_ON_CLOSE 或 3 ，这两个式子是等价的。<br><strong>修饰界面</strong><br>创建了界面之后，我们就可以就可以对其进行修饰。首先我们定义组件的排列方式为流式排列：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">FlowLayout fl=<span class="keyword">new</span> <span class="title class_">FlowLayout</span>();</span><br><span class="line">	jf.setLayout(fl);</span><br></pre></td></tr></tbody></table></figure>
<p>其次，我们创建一系列组件：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   ImageIcon image=<span class="keyword">new</span> <span class="title class_">ImageIcon</span>(<span class="string">"C:\\Users\\15593\\Pictures\\Saved Pictures\\bg1.jpg"</span>);</span><br><span class="line">JLabel imagela=<span class="keyword">new</span> <span class="title class_">JLabel</span>(image);</span><br><span class="line">JLabel name=<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">"账号"</span>);</span><br><span class="line"><span class="type">JLabel</span> <span class="variable">password</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">"密码"</span>);</span><br><span class="line">	</span><br><span class="line">JTextField namein=<span class="keyword">new</span> <span class="title class_">JTextField</span>();</span><br><span class="line">JPasswordField passin=<span class="keyword">new</span> <span class="title class_">JPasswordField</span>();</span><br><span class="line">JButton btn=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"登录"</span>);</span><br><span class="line">JCheckBox check1=<span class="keyword">new</span> <span class="title class_">JCheckBox</span>(<span class="string">"记住密码"</span>);</span><br><span class="line">JCheckBox check2=<span class="keyword">new</span> <span class="title class_">JCheckBox</span>(<span class="string">"自动登录"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>而要创建这些组件，我们也要事先导入这些组件的包：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Dimension;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JCheckBox;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPasswordField;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JTextField;</span><br></pre></td></tr></tbody></table></figure>
<p>其中，引用的图片可以是储存在电脑中时的路径名，也可以是放在Project中的图像名。让我们对按钮进行一定的修饰：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Dimension dim=<span class="keyword">new</span> <span class="title class_">Dimension</span>(<span class="number">330</span>,<span class="number">30</span>);</span><br><span class="line">btn.setBackground(Color.WHITE);</span><br><span class="line">namein.setPreferredSize(dim);</span><br><span class="line">passin.setPreferredSize(dim);</span><br></pre></td></tr></tbody></table></figure>
<p>这几行代码分别规定了按钮的背景颜色和两个输入文本框的大小。但要记得，创建完组件后要将组件添加到界面里：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">jf.add(imagela);</span><br><span class="line">jf.add(name);</span><br><span class="line">jf.add(namein);</span><br><span class="line">jf.add(password);</span><br><span class="line">jf.add(passin);</span><br><span class="line">jf.add(check1);</span><br><span class="line">jf.add(check2);</span><br><span class="line">jf.add(btn);</span><br><span class="line">jf.setVisible(<span class="literal">true</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>记得一定要记得写最后一行代码，不然界面会一闪而过！</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/0191013210828606.png" alt="在这里插入图片描述">

<p>一个界面就这样成功实现了。<br><strong>事件监听</strong><br>实现了界面之后，我们就要实现一定界面的功能。于是我们创建监听器，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 界面;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JTextField;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span>{</span><br><span class="line"></span><br><span class="line">	JTextField nametx;</span><br><span class="line">	JTextField passtx;</span><br><span class="line">	JFrame jf;</span><br><span class="line">	Pad3DBall pad3dball;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> {</span><br><span class="line">		</span><br><span class="line">		 <span class="type">String</span> <span class="variable">nameString</span> <span class="operator">=</span> nametx.getText();</span><br><span class="line">		 <span class="type">String</span> <span class="variable">passString</span> <span class="operator">=</span> passtx.getText();</span><br><span class="line">		 </span><br><span class="line">		 <span class="keyword">if</span> (passString.equals(<span class="string">""</span>)) {</span><br><span class="line">					System.out.println(<span class="string">"请输入密码"</span>);</span><br><span class="line">		 }<span class="keyword">else</span> {</span><br><span class="line">			 </span><br><span class="line">		 <span class="keyword">if</span> (nameString.equals(<span class="string">"123456"</span>)&amp;&amp;passString.equals(<span class="string">"456789"</span>)) {</span><br><span class="line">					System.out.println(<span class="string">"账号正确"</span>);</span><br><span class="line">					jf.setVisible(<span class="literal">false</span>);</span><br><span class="line">					<span class="type">Pad3DBall</span> <span class="variable">pad3dball</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pad3DBall</span>();</span><br><span class="line">					pad3dball.intUI();</span><br><span class="line">		 }<span class="keyword">else</span> {</span><br><span class="line">					System.out.println(<span class="string">"账号输入错误"</span>);</span><br><span class="line">		 }</span><br><span class="line">			 </span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们用一个类去实现接口，即 implements<br>其格式：public class 类名 implements 接口名{ } ，其中不能创建带有具体方法体的方法，因此我们需要将方法后的大括号改为分号，化具体为抽象：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   JTextField nametx;</span><br><span class="line">JTextField passtx;</span><br><span class="line">JFrame jf;</span><br><span class="line">Pad3DBall pad3dball;</span><br></pre></td></tr></tbody></table></figure>
<p>之后我们重载监听器接口的抽象方法</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> {</span><br><span class="line">		</span><br><span class="line">		 <span class="type">String</span> <span class="variable">nameString</span> <span class="operator">=</span> nametx.getText();</span><br><span class="line">		 <span class="type">String</span> <span class="variable">passString</span> <span class="operator">=</span> passtx.getText();</span><br><span class="line">		 </span><br><span class="line">		 <span class="keyword">if</span> (passString.equals(<span class="string">""</span>)) {</span><br><span class="line">					System.out.println(<span class="string">"请输入密码"</span>);</span><br><span class="line">		 }<span class="keyword">else</span> {</span><br><span class="line">			 </span><br><span class="line">		 <span class="keyword">if</span> (nameString.equals(<span class="string">"123456"</span>)&amp;&amp;passString.equals(<span class="string">"456789"</span>)) {</span><br><span class="line">					System.out.println(<span class="string">"账号正确"</span>);</span><br><span class="line">					jf.setVisible(<span class="literal">false</span>);</span><br><span class="line">					<span class="type">Pad3DBall</span> <span class="variable">pad3dball</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pad3DBall</span>();</span><br><span class="line">					pad3dball.intUI();</span><br><span class="line">		 }<span class="keyword">else</span> {</span><br><span class="line">					System.out.println(<span class="string">"账号输入错误"</span>);</span><br><span class="line">		 }</span><br><span class="line">			 </span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>
<p>在这些方法中，我们首先提取了账户密码输入框中用户输入的字符串，将其跟我们既定的数据进行比较，用<code>equals("......")</code>来实现，输入正确后，按下登录按钮就可以执行我们既定的程序了。 其中，<code>jf.setVisible(false);</code>关闭了登录界面，而<code>Pad3DBall pad3dball = new Pad3DBall();                     pad3dball.intUI();</code>则执行绘制了一个图像，这里代码从略。<br>最后，我们将监听器应用到我们的主程序中，在按下按钮（btn）后执行：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">LoginListener</span> <span class="variable">nll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginListener</span>();</span><br><span class="line">btn.addActionListener(nll);</span><br><span class="line">nll.passtx=passin;</span><br><span class="line">nll.nametx=namein;</span><br><span class="line">nll.jf=jf;</span><br></pre></td></tr></tbody></table></figure>
<p>我们正确输入账户密码后按下“登录”，执行结果如下：</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/0191013214124480.png" alt="在这里插入图片描述" style="zoom:67%;">

<p>以上就是简单的界面实现及事件的监听方法了。<br>感谢观看！</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Overview of innovative application for Diffusion</title>
    <url>/2023/11/01/Diffusion-4-Protein/</url>
    <content><![CDATA[<h1 id="Diffusion-Model-4-Protein"><a href="#Diffusion-Model-4-Protein" class="headerlink" title="Diffusion Model 4 Protein"></a>Diffusion Model 4 Protein</h1><p>​	Inverse protein folding is challenging due to its inherent one-to-many mapping</p>
<p>characteristic, where numerous possible amino acid sequences can fold into a single,</p>
<p>identical protein backbone. This task involves not only identifying viable sequences</p>
<p>but also representing the sheer diversity of potential solutions. This article is the overview of the technology utilized by <strong>Graph Denoising Diffusion for Inverse Protein Folding</strong>.</p>
<span id="more"></span>

<h2 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h2><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016220405922.png" alt="image-20231016220405922" style="zoom:33%;">

<p>​	残差学习就是改变传统的网络结构，将层间传输的数据转换为F(x)+x的形式。优势在于梯度不会随着导数的相乘而快速趋近于0，使得网络在达到Plateau后继续下降收敛。</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016220953678.png" alt="image-20231016220953678" style="zoom:33%;">

<h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><p>​	序列转录模型，运用Attention机制，取得了全局信息的抽取效果，而且避免了RNN存在的诸如梯度消失和难以并行计算的缺点。</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016221240166.png" alt="image-20231016221240166" style="zoom: 50%;">

<p>​	同样运用了Residual的链接方式和样本层面的layer norm，能够处理边长序列的样本信息。</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016221452280.png" alt="image-20231016221452280" style="zoom:33%;">

<p>​	此外，1）还要注意decoder的Mask机制，以及类似条件概率的序列生成方式 。2）Attention无法取得序列的位置信息，所以需要对位置进行cos的编码，使得MLP层能够学习到顺序Info。</p>
<h2 id="GNN"><a href="#GNN" class="headerlink" title="GNN"></a>GNN</h2><p>​	图神经网络利用的图这种数据结构intrinsically具有的强大特点，对于各种数据有这很好的结构化表示，详细介绍Distill：<a href="https://distill.pub/2021/gnn-intro/">A Gentle Introduction to Graph Neural Networks (distill.pub)</a></p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016222632434.png" alt="image-20231016222632434" style="zoom:67%;">

<p>​	对于一个图数据，可以对顶点、边以及全局信息分别应用MLP进行学习，在通过数据相互传到的技巧，可以良好地学习到数据整体地特征。</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016222814266.png" alt="image-20231016222814266" style="zoom:67%;">

<h2 id="What-is-GAN"><a href="#What-is-GAN" class="headerlink" title="What is GAN"></a>What is GAN</h2><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016223524288.png" alt="image-20231016224042238" style="zoom:50%;">

<p>​	GAN = Generative Adversarial Networks，生成对抗网络。即同时定义两个网络，生成器G和判别器D。通过博弈论新设计的目标函数，同时对两个网络进行对抗式的训练。最终达成的目的是使得G生产的图片非常趋近于Ground Truth的图片(图d)，而D无法分辨，收敛到1/2:</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016224042238.png" alt="image-20231016224042238" style="zoom:50%;">

<h2 id="Diffusion-Model-Overview-Via-DALLE-2"><a href="#Diffusion-Model-Overview-Via-DALLE-2" class="headerlink" title="Diffusion Model Overview Via DALLE-2"></a>Diffusion Model Overview Via DALLE-2</h2><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016225558737.png" alt="image-20231016225558737" style="zoom:50%;">

<p>​	概率扩散模型, 实用的DDPM运用残差学习的思想, 在Reverse过程中, 不通过Xt到Xt-1直接得到,而是学习所加的噪声. 因为通过共享权重的U-Net来进行全局的预测,需要对位置进行 Time Embeding. </p>
<h3 id="Classifier-Guided-Diffusion"><a href="#Classifier-Guided-Diffusion" class="headerlink" title="Classifier-Guided Diffusion"></a>Classifier-Guided Diffusion</h3><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016231307655.png" alt="image-20231016231307655" style="zoom: 50%;">

<p>​	Diffusion Beats GAN中提出的方法,不仅可以用Classifier来指导训练, CLIP, LLM等都可以用来作为Guide函数. </p>
<h3 id="Classifier-Free-Diffusion"><a href="#Classifier-Free-Diffusion" class="headerlink" title="Classifier-Free Diffusion"></a>Classifier-Free Diffusion</h3><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016231456302.png" alt="image-20231016231456302" style="zoom: 50%;">

<p>​	优化的目标函数变更. 通过学习有无条件生成X之间的Gap, 可以实现将即使在无条件下生成的图片转换成有条件Guide的图片. </p>
<h2 id="AlphaFold2"><a href="#AlphaFold2" class="headerlink" title="AlphaFold2"></a>AlphaFold2</h2><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016233300342.png" alt="image-20231016233300342" style="zoom:67%;">

<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016233824554.png" alt="image-20231016233824554" style="zoom:67%;">

<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231017004041504.png" alt="image-20231017004041504" style="zoom:67%;">

<p>​	Nature补充材料: <a href="https://www.nature.com/articles/s41586-021-03819-2#MOESM3">Highly accurate protein structure prediction with AlphaFold | Nature</a></p>
<h2 id="Turnover-number-DLKcat"><a href="#Turnover-number-DLKcat" class="headerlink" title="Turnover number &amp; DLKcat"></a>Turnover number &amp; DLKcat</h2><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016232316214.png" alt="image-20231016232316214" style="zoom: 67%;">

<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016232812110.png" alt="image-20231016232812110" style="zoom: 67%;">

<p>​	<strong>底物 Substrate</strong>: Substrate refers to the specific molecule or molecules that an enzyme acts upon in an enzymatic reaction. Enzymes bind to their substrates at their active sites, which are specific regions of the enzyme’s structure that complement the shape and chemical properties of the substrate(s). This binding of the substrate to the enzyme’s active site forms an enzyme-substrate complex.</p>
<h2 id="Protein-Graph"><a href="#Protein-Graph" class="headerlink" title="Protein Graph"></a>Protein Graph</h2><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016234338343.png" alt="image-20231016234338343" style="zoom:67%;">

<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231017012342420.png" alt="image-20231017012342420" style="zoom:67%;">

<h2 id="DataSet"><a href="#DataSet" class="headerlink" title="DataSet"></a>DataSet</h2><p><strong>CATH</strong>: Protein Structure Classification Database at UCL, which conducts 151 million protein domains classified into 5,841 superfamilies. 使用wget方法下载. </p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016004238773.png" alt="image-20231016004238773" style="zoom: 67%;">

<p><strong>Website</strong>: <a href="https://www.cathdb.info/">CATH: Protein Structure Classification Database at UCL (cathdb.info)</a></p>
<p><strong>Protein Domain</strong>: </p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/Photo/image-20231016005008584.png" alt="image-20231016005008584" style="zoom:67%;"> 

<h2 id="Inductive-Bias-and-Learning-Rule"><a href="#Inductive-Bias-and-Learning-Rule" class="headerlink" title="Inductive Bias and Learning Rule"></a>Inductive Bias and Learning Rule</h2>]]></content>
      <categories>
        <category>AI4Science</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/10/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Fractals and Chaos | 分形与混沌</title>
    <url>/2020/01/02/%E5%88%86%E5%BD%A2%E4%B8%8E%E6%B7%B7%E6%B2%8C%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="分形与混沌（二）"><a href="#分形与混沌（二）" class="headerlink" title="分形与混沌（二）"></a>分形与混沌（二）</h1><p>笔者在上一篇博客中简单地介绍了几种分形体，现在就让我们试着在Java环境中实现一些简单的分形体。</p>
<h3 id="简单IFS（Iterated-Functions-Systems-）分形"><a href="#简单IFS（Iterated-Functions-Systems-）分形" class="headerlink" title="简单IFS（Iterated Functions Systems ）分形"></a>简单IFS（Iterated Functions Systems ）分形</h3><p>一如既往，我们首先实现一个界面及其监听器来方便我们画图。读者如果不了解具体方法可参照笔者之前的博客，这里不再赘述。</p>
<span id="more"></span>

<p>我们先来画一个简单的球形：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">1.7</span>, b = -<span class="number">2</span>, c = -<span class="number">2</span>, d = -<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) {</span><br><span class="line">			x = d * Math.sin(a * x) - Math.sin(b * y);</span><br><span class="line">			y = c * Math.cos(a * x) + Math.cos(b * y);</span><br><span class="line">			<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (<span class="type">int</span>) ((d * Math.sin(a * x) - Math.sin(b * y)) * <span class="number">100</span> + <span class="number">400</span>);</span><br><span class="line">			<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) ((c * Math.cos(a * x) + Math.cos(b * y)) * <span class="number">100</span> + <span class="number">400</span>);</span><br><span class="line">			gr.drawLine(m, n, m, n);</span><br><span class="line">			gr.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">250</span>, i % <span class="number">255</span>, i % <span class="number">155</span>));</span><br><span class="line">		}</span><br></pre></td></tr></tbody></table></figure>
<p>代码中的 a、b、c、d 为我们拟定的参数，它们决定了整个分形图形的形状。我们将参数代入公式，用 for循环 来实现100000次的递归，每递归一次画一个点。 要注意的是，画在JFrame上的点应为整数，所以我们在画之前须将坐标 m、n 强制转型为整型。<br><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191112221239493.png" alt="在这里插入图片描述"><br>如果我们将参数稍加修改（double a = -2, b =-30, c = -1.9, d = 1.9;）则有：</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191112223427439.png" alt="在这里插入图片描述">

<p>类似地，还有：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0f</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0f</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">1.7</span>, b = <span class="number">1.8</span>, c = -<span class="number">1.9</span>, d = <span class="number">0.4</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">255000</span>; i++) {</span><br><span class="line">		<span class="type">double</span> <span class="variable">temx</span> <span class="operator">=</span> Math.sin(a * y) + c * Math.cos(a * x);</span><br><span class="line">		<span class="type">double</span> <span class="variable">temy</span> <span class="operator">=</span> Math.sin(b * x) + d * Math.cos(b * y);</span><br><span class="line">		<span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> (<span class="type">int</span>) (temx * <span class="number">130</span> + <span class="number">400</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">y1</span> <span class="operator">=</span> (<span class="type">int</span>) (temy * <span class="number">130</span> + <span class="number">400</span>);</span><br><span class="line">		gr.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">100</span>, i % <span class="number">255</span>, i % <span class="number">155</span>));</span><br><span class="line">		gr.drawLine(x1, y1, x1, y1);</span><br><span class="line">		x = temx;	y = temy;</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/2019111222440965.png" alt="在这里插入图片描述">

<p>是不是很神奇呢？ 读者可以自己尝试着修改参数。期待你们的作品哦。</p>
<h3 id="随机参数画法（Gallery-of-Randomly-Generated-IFS）"><a href="#随机参数画法（Gallery-of-Randomly-Generated-IFS）" class="headerlink" title="随机参数画法（Gallery of Randomly Generated IFS）"></a>随机参数画法（Gallery of Randomly Generated IFS）</h3><p>这里的实现思路基本与简单IFS相同。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> rda[] = { <span class="number">0.1400</span>, <span class="number">0.4300</span>, <span class="number">0.4500</span>, <span class="number">0.4900</span> };</span><br><span class="line"><span class="type">double</span> rdb[] = { <span class="number">0.0100</span>, <span class="number">0.5200</span>, -<span class="number">0.4900</span>, <span class="number">0.0000</span> };</span><br><span class="line"><span class="type">double</span> rdc[] = { <span class="number">0.0000</span>, -<span class="number">0.4500</span>, <span class="number">0.4700</span>, <span class="number">0.0000</span> };</span><br><span class="line"><span class="type">double</span> rdd[] = { <span class="number">0.5100</span>, <span class="number">0.5000</span>, <span class="number">0.4700</span>, <span class="number">0.5100</span> };</span><br><span class="line"><span class="type">double</span> rde[] = { -<span class="number">0.0800</span>, <span class="number">1.4900</span>, -<span class="number">1.6200</span>, <span class="number">0.0200</span> };</span><br><span class="line"><span class="type">double</span> rdf[] = { -<span class="number">1.3100</span>, -<span class="number">0.7500</span>, -<span class="number">0.7400</span>, <span class="number">1.6200</span> };</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) {</span><br><span class="line">		<span class="type">Random</span> <span class="variable">ran</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">		<span class="type">int</span> <span class="variable">rr</span> <span class="operator">=</span> ran.nextInt(<span class="number">4</span>);</span><br><span class="line">		<span class="type">double</span> <span class="variable">temx</span> <span class="operator">=</span> rda[rr] * x + rdb[rr] * y + rde[rr];</span><br><span class="line">		<span class="type">double</span> <span class="variable">temy</span> <span class="operator">=</span> rdc[rr] * x + rdd[rr] * y + rdf[rr];</span><br><span class="line">		<span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> (<span class="type">int</span>) (temx * <span class="number">100</span> + <span class="number">400</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">y1</span> <span class="operator">=</span> (<span class="type">int</span>) (temy * <span class="number">100</span> + <span class="number">400</span>);</span><br><span class="line">		gr.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">224</span>,<span class="number">76</span>,<span class="number">49</span>));</span><br><span class="line">		gr.drawLine(x1, y1, x1, y1);</span><br><span class="line">		x = temx; y = temy;</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>
<p>要注意的是，这里需要运用随机数组，每组参数（a、b、c、d ）的值如代码中展示。我们运用随机数<code>Random ran = new Random();             int rr = ran.nextInt(4);</code>来锚定每次选取哪一组参数。执行结果如下：</p>
<p>如图所示，我们得到了一个IFS枫叶。在这里，分形图形的自相似性质就非常明显了。照此思路，我们尝试修改参数：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">double</span> rda[] = { <span class="number">0.0000</span> ,<span class="number">0.7248</span> ,<span class="number">0.1583</span> , <span class="number">0.3386</span> };</span><br><span class="line"><span class="type">double</span> rdb[] = { <span class="number">0.2439</span> , <span class="number">0.0337</span> , -<span class="number">0.1297</span>, <span class="number">0.3694</span> };</span><br><span class="line"><span class="type">double</span> rdc[] = { <span class="number">0.0000</span> , -<span class="number">0.0253</span> , <span class="number">0.3550</span>, <span class="number">0.2227</span> };</span><br><span class="line"><span class="type">double</span> rdd[] = { <span class="number">0.3053</span>, <span class="number">0.7426</span>, <span class="number">0.3676</span> , -<span class="number">0.0756</span> };</span><br><span class="line"><span class="type">double</span> rde[] = { <span class="number">0.0000</span>, <span class="number">0.2060</span>, <span class="number">0.1383</span>, <span class="number">0.0679</span> };</span><br><span class="line"><span class="type">double</span> rdf[] = { <span class="number">0.0000</span>, <span class="number">0.2538</span>, <span class="number">0.1750</span>, <span class="number">0.0826</span> };</span><br></pre></td></tr></tbody></table></figure>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191112234451607.png" alt="在这里插入图片描述">

<p>再比如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> rda[] = { <span class="number">0.2020</span>, <span class="number">0.1380</span> };</span><br><span class="line"><span class="type">double</span> rdb[] = { -<span class="number">0.8050</span>, <span class="number">0.6650</span> };</span><br><span class="line"><span class="type">double</span> rdc[] = { -<span class="number">0.6890</span>, -<span class="number">0.5020</span> };</span><br><span class="line"><span class="type">double</span> rdd[] = { -<span class="number">0.3420</span>, -<span class="number">0.2220</span> };</span><br><span class="line"><span class="type">double</span> rde[] = { -<span class="number">0.3730</span>, <span class="number">0.6600</span> };</span><br><span class="line"><span class="type">double</span> rdf[] = { -<span class="number">0.6530</span>, -<span class="number">0.2770</span> };</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) {</span><br><span class="line">		<span class="type">Random</span> <span class="variable">ran</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">		<span class="type">int</span> <span class="variable">rr</span> <span class="operator">=</span> ran.nextInt(<span class="number">2</span>);</span><br><span class="line">		<span class="type">double</span> <span class="variable">temx</span> <span class="operator">=</span> rda[rr] * x + rdb[rr] * y + rde[rr];</span><br><span class="line">		<span class="type">double</span> <span class="variable">temy</span> <span class="operator">=</span> rdc[rr] * x + rdd[rr] * y + rdf[rr];</span><br><span class="line">		<span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> (<span class="type">int</span>) (temx * <span class="number">550</span> + <span class="number">330</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">y1</span> <span class="operator">=</span> (<span class="type">int</span>) (temy * <span class="number">550</span> + <span class="number">670</span>);</span><br><span class="line">		gr.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">250</span>, i % <span class="number">255</span>, i % <span class="number">155</span>));</span><br><span class="line">		gr.drawLine(x1, y1, x1, y1);</span><br><span class="line">		x = temx;  y = temy;</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191112232153553.png" alt="在这里插入图片描述">

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>IFS分形是分形学科重要的分支之一。它的算法相对简单，但却依然能绘制出瑰丽的图形，体现着几何之美。探索之路，永无止境，分形还有着无穷的秘密等待我们去发掘。IFS分形还可以用来实现一些缓冲动画与空间矩阵，在以后的博客中，笔者会一一为读者介绍 。下篇博客将会介绍一些简单的谢尔宾斯基（Sierpinski）分形，敬请期待。</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191112234008944.png" alt="在这里插入图片描述">]]></content>
      <categories>
        <category>Vision</category>
      </categories>
  </entry>
  <entry>
    <title>Fractals and Chaos | 分形与混沌</title>
    <url>/2019/11/13/%E5%88%86%E5%BD%A2%E4%B8%8E%E6%B7%B7%E6%B2%8C%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="分形与混沌（Chapter-1）"><a href="#分形与混沌（Chapter-1）" class="headerlink" title="分形与混沌（Chapter 1）"></a>分形与混沌（Chapter 1）</h2><h3 id="分形概述"><a href="#分形概述" class="headerlink" title="分形概述"></a>分形概述</h3><p>分形（英语：fractal，源自拉丁语：frāctus，有“零碎”、“破裂”之意），又称碎形、残形，通常被定义为“一个粗糙或零碎的几何形状，可以分成数个部分，且每一部分都（至少近似地）是整体缩小后的形状”即具有自相似的性质。<br>分形在数学中是一种抽象的物体，用于描述自然界中存在的事物。而人工实现的分形通常在放大后能展现出相似的形状，因此分形也被称为扩展对称或展开对称。如果在每次放缩（递归）后，图形形状的重复是完全相同的，这就被称为自相似。自相似的典型例子如门格海绵：</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191110224110830.png" style="zoom:67%;">

<span id="more"></span>

<p>如图所示，这就是一个递归了5次的 门格海绵，它的每一个单元都是自相似的。</p>
<p>分形图像自身细节的重复意味分形与其他几何图形相似但又有所不同。当你放缩一个图形时，你就能看出分形和其他几何图形的区别：</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191110225356770.png" style="zoom:67%;">

<p>如果将分形的一维长度加倍，分型空间填充变为 2的n次方 倍，但此时n 不一定是个整数，指数 n 称为分型的维数。</p>
<p>作为一个数学函数，分形通常是处处不可微的。无穷分形曲线可以理解为一条一维的曲线在空间中绕行，它的拓扑维数仍然是 1，但大于 1 的分形维数暗示了它有着类似曲面的性质。</p>
<p>总之，分形作为一个重要的数学分支，从17世纪被提出至今，有着庞大而复杂的学术体系与应用方向，这里不再赘述。感兴趣的读者可以去维基百科自行查阅。</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191110233504839.png" style="zoom:80%;">

<h3 id="分形——解构世界的算法"><a href="#分形——解构世界的算法" class="headerlink" title="分形——解构世界的算法"></a>分形——解构世界的算法</h3><p>如图所示，根据分形原理，如果将一棵树的树杈不断缩放，去观察局部，那么自相似的性质就非常明显了。</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/image-20231103101111097.png" style="zoom:80%">

<img src="//raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/image-20231103101345938.png" alt="image-20231103101345938" style="zoom:67%;">

<p>再比如说斐波那契螺旋线分形：</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191110233618887.png" style="zoom:90%;">

<p float="left">   
    <img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191110233637623.png">   
    <img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191110233556785.png">
</p>

<p>混沌之谜–逻辑斯蒂方程</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191110234403456.png" style="zoom:80%">

<h3 id="分形举例"><a href="#分形举例" class="headerlink" title="分形举例"></a>分形举例</h3><h4 id="噪声："><a href="#噪声：" class="headerlink" title="噪声："></a>噪声：</h4><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/image-20231103101448413.png" alt="image-20231103101448413" style="zoom:67%;">

<h4 id="多面体："><a href="#多面体：" class="headerlink" title="多面体："></a>多面体：</h4><p>帕斯卡三角形  &amp; 塞尔宾斯基堆</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/201911102356059.png" alt="image-20231103101550473" style="zoom:67%;">

<p>塞尔宾斯基地毯</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191110235850975.png">



<p> 除此之外还有门格海绵、开普勒多面体等。</p>
<h4 id="IFS分形"><a href="#IFS分形" class="headerlink" title="IFS分形"></a>IFS分形</h4><img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/image-20231103101646775.png" alt="image-20231103101646775" style="zoom:80%;"> 

<p>还有类似于上文的 枫叶 也属于IFS分形。</p>
<h4 id="L-系统"><a href="#L-系统" class="headerlink" title="L-系统"></a>L-系统</h4><p> 这个类型的分形常用来实现类似上文中植物的分形。这里因为篇幅不再举例。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p> 分形的种类繁多，瑰丽而奇异。这其中蕴含这无数数学家与程序员的智慧。笔者才疏学浅，即使绞尽脑汁，也仅能勘知一二。一个分形体既可以仅仅是一条1.26维的线段，也可以是绚丽的3D效果（如光线追踪）。本篇博客简单介绍了分形的一些概念即其种类，笔者会在接下来的博客中详细介绍用Java语言实现几种简单分形体的具体方法，不定期更新，敬请关注哦。</p>
<img src="https://raw.githubusercontent.com/EDAttlee/edattlee.github.io/main/downloaded_images/20191111002040693.png" style="zoom:80%">

]]></content>
      <categories>
        <category>Vision</category>
      </categories>
  </entry>
  <entry>
    <title>Fundamental Sorting | 基本排序算法</title>
    <url>/2018/12/07/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>排序就是将给定数据按照一定的顺序（升序或降序）重新排列。 排序是许多算法的基础，可以让数据变得容易处理。<br>排序时，需要先确定排序的基准，即“排序键”；在选择排序算法时，<strong>时间复杂度、空间复杂度</strong> 和 <strong>稳定排序</strong> 都是重要的考量标准。 所谓稳定排序，即指在数据中含有键值相等的元素，其在排序完成后顺序不变。<br>时至今日，人们已经开发出了许多种排序方法，其机制个不相同。 我们要根据实际情况，选择适宜的排序方法：</p>
<ul>
<li><strong>复杂度与稳定性</strong></li>
<li>除了原有数据外是否还需要<strong>额外的内存</strong></li>
<li><strong>输入数据的特征</strong>可能会影响算法的效率</li>
</ul>
<p> 虽然各种编程语言的库中都有标准排序算法供我们使用，但是，算法乃是程序员的自我修养，而排序是算法的基础，深入理解其原理可以为我们将来实现其他功能提供思路与方法。</p>
<span id="more"></span>

<h3 id="初等排序"><a href="#初等排序" class="headerlink" title="初等排序"></a>初等排序</h3><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>插入排序将待排序数据分为 已排序 和 未排序 部分，取出未排序部分的开头元素，将它的值储存在临时变量v里，然后<strong>将所有比v大的元素都后移一位</strong>，再将v插入到空位里。这就是插入排序了，很简单吧，我们直接上代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertsort</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> arr[])</span> </span>{</span><br><span class="line">	<span class="type">int</span> v, j;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) { <span class="comment">// 假设设第一个[0]元素已经排好，从1开始循环</span></span><br><span class="line">		v = arr[i]; <span class="comment">// 以v作为比较基准，即未排序部分的开头元素值</span></span><br><span class="line">		j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 进行移动，将所有大于v的元素后移一个单位</span></span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; v) { <span class="comment">// 注意循环条件</span></span><br><span class="line">			arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">			j--;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// 最后将v插入在恰当位置，即所有小于等于v的元素之前</span></span><br><span class="line">		arr[j + <span class="number">1</span>] = v; <span class="comment">// 注意：寻找到插入位置后仍然会执行 j--</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>分析插入排序的特征，我们可以发现，因为插入排序不会直接交换不相邻的元素，而是将所有比当前元素键值大的元素后移，因此，插入排序是稳定的。<br>再看看复杂度，在<strong>最极端的条件下</strong>，我们需要将 每个i循环 进行i次移动，总共需要1+2+……+N-1=(N^2 -N)次移动，当N很大时，我们可以忽略N的项而保留 N平方 的项，即插入排序的时间复杂度O(N*N)。但是如果是已经按照升序排列好的数组，我们只需要N次比较就可以完成排序。 由此可见，输入数据的特征可以明显影响排序的效率。亦可以看出，<strong>插入排序能够快速处理相对有序的数据</strong>，这一点很重要，在高等排序的 希尔排序 中会对这一特性进行扩展。</p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序实现简单，使用广泛。它的机制是依次比较相邻元素，将所有大小关系相反的数据交换：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span>* q)</span> </span>{</span><br><span class="line">	<span class="type">int</span> tem = *p;</span><br><span class="line">	*p = *q;</span><br><span class="line">	*q = tem;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 冒泡排序算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bubblesort</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> arr[])</span> </span>{</span><br><span class="line">	<span class="type">int</span> times = <span class="number">0</span>;</span><br><span class="line">	<span class="type">bool</span> flag = <span class="number">1</span>;			   <span class="comment">// 发挥外层变量i的作用</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;flag;i++) { <span class="comment">// 已经排序完成的前i个元素不需要再次进行比较</span></span><br><span class="line">		flag = <span class="number">0</span>;			   <span class="comment">// 每次需比较至i+1</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>;j &gt;= i + <span class="number">1</span>;j--) { <span class="comment">// 从数组末尾开始循环防止溢出</span></span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) {</span><br><span class="line">				<span class="built_in">swap</span>(arr[j], arr[j - <span class="number">1</span>]);</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">				times++;</span><br><span class="line">			}</span><br><span class="line">		} <span class="comment">// 当某一次循环中不发生交换时则证明已经排序完成</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> times; <span class="comment">// 返回交换次数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>类似的，我们对冒泡排序算法进行分析，其在最坏的情况下需要（N^2 -N）次比较，即算法时间复杂度为O(N*N)。顺带一提，函数返回的交换次数也称为逆序数，反应了数据的混乱程度。</p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>同样的，选择排序也将数组分为 已排序 和 未排序 的部分。 找出未排序部分的最小(大)值的位置下标 min_j (max_j)，将min_j 位置的元素与未排序部分的开头元素交换，重复N-1次(N个元素，最多换N-1次)：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 选择排序算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">selectionsort</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> arr[])</span> </span>{</span><br><span class="line">	<span class="type">int</span> times, min_j;</span><br><span class="line">	times = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++) { <span class="comment">// i表示未排序部分的开头元素下标</span></span><br><span class="line">		min_j = i; <span class="comment">// min_j 表示每轮循环中 第i 到 第N-1 元素中 最小值的下标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i;j &lt; n;j++) { <span class="comment">// 更新最小值下标</span></span><br><span class="line">			<span class="keyword">if</span> (arr[min_j] &gt; arr[j]) min_j = j;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">swap</span>(arr[i], arr[min_j]);</span><br><span class="line">		<span class="keyword">if</span> (i != min_j) times++; <span class="comment">// 若最小值为arr[i]本身则无需交换</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> times;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>要注意的是，选择排序会<strong>交换不相邻的元素</strong>，因此可能出现排序键值相等而元素顺序改变的情况，例如：数组{3H,5L,3D,1S}，在对 数字键值 执行选择排序后，会变成{1S,3D,3H,5L} （大家可以自行验证）。可见，<strong>选择排序是不稳定的</strong>。<br>再来看看复杂度，无论在什么情况下，选择排序都要进行（N^2-N）/2 次比较运算，复杂度与N*N成正比。</p>
<h4 id="初等排序小结"><a href="#初等排序小结" class="headerlink" title="初等排序小结"></a>初等排序小结</h4><p>综合来观察三种初等排序方法。冒泡排序从局部出发，逐项比较，减少逆序数；选择排序面向整体，逐个选择最小（大）值。虽然这二者思路大相径庭，但是我们可以看出，冒泡排序 和 选择排序 不依赖输入数据。而与之相对的，插入算法却很依赖数据，处理相对有序的数据有很高的效率。</p>
<h3 id="高等排序"><a href="#高等排序" class="headerlink" title="高等排序"></a>高等排序</h3><p>虽然初等排序在应对一般数据时已经有很好的效果，但是在非常庞大的数据面前便会失去效果。因此，我们就需要运用高等排序。 高等排序是通过运用 <strong>分治法与递归法</strong>，结合初等排序思路 进行优化而实现的高速算法。</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>上文提到过，插入排序 在针对相对有序的数据时具有非常高的效率。而 希尔排序就是针对这一特性而实现的高速算法。<br>希尔排序的思路是，<strong>重复进行以间隔为g的插入排序，g的值逐轮减小，最后再执行 间隔g=1 的一般插入排序</strong>。 为什么要进行这样的操作呢？<br>其实，每一轮以g为间隔时，其实都是把选出来的数据组成一个新的数组，这些数组的元素数目N’相对N来讲很小。第一轮时，g1约为数据量N的1/3~ 1/2 ，这些分割出来的数组只有2~3个元素，进行排序非常快捷。第二轮时，经过第一轮的处理，此时的数组相对原数组变得相对有序了一些（好吧，虽然只有一点点，(⊙o⊙)），此时，间隔g2减小，继续执行排序，这些小数组又变得有序了。 继续一轮轮的执行这些操作，间隔g逐渐减小；<strong>每一轮操作时，因为之前的插入排序，对数据整体来说，此时的数组已经变得相对有序了很多</strong>。所以此时在执行当前g的插入排序，效率比直接执行此gap的插入排序提高了非常多。<br>根据这个原理，<strong>最后在执行 g=1 的插入排序时，因为数据已经变得非常有序了，此时的排序效率非常高</strong>。<br>那么，由此可见，希尔排序的效率就跟Gap间隔数组的选择有很大的关系，根据数学原理，当递推关系式为：g(n+1) = 3*g(n)+1 时，希尔排序的复杂度基本稳定在O(N^1.25)。具体数学原理本文就不做讨论了（才不是因为论文太难看不懂呢😂）。但要注意的是，如果Gap间隔数组为2的幂指数，则算法的效率会大打折扣。代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionsort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> g)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellsort</span><span class="params">(<span class="type">int</span> arr[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> cnt;</span><br><span class="line"><span class="type">int</span> arr[LEN];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; Gap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; LEN;i++) {</span><br><span class="line">		arr[i] = <span class="built_in">rand</span>() % <span class="number">10000</span> + <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; LEN;i++) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%6d"</span>, arr[i]);</span><br><span class="line">		<span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="built_in">shellsort</span>(arr);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; LEN;i++) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%6d"</span>, arr[i]);</span><br><span class="line">		<span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>, cnt);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// ShellSort算法核心</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionsort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> g)</span> </span>{ <span class="comment">// 指定gap的插入排序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = g;i &lt; LEN;i++) {</span><br><span class="line">		<span class="type">int</span> v = arr[i];</span><br><span class="line">		<span class="type">int</span> j = i - g;</span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; v) {</span><br><span class="line">			arr[j + g] = arr[j];</span><br><span class="line">			j -= g;</span><br><span class="line">			cnt++;</span><br><span class="line">		}</span><br><span class="line">		arr[j + g] = v;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellsort</span><span class="params">(<span class="type">int</span> arr[])</span> </span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">1</span>;;) { <span class="comment">// 递推公式生成Gap数组</span></span><br><span class="line">		<span class="keyword">if</span> (h &gt; LEN) <span class="keyword">break</span>;</span><br><span class="line">		Gap.<span class="built_in">push_back</span>(h);</span><br><span class="line">		h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = Gap.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) {</span><br><span class="line">		<span class="built_in">insertionsort</span>(arr, Gap[i]);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>类似于希尔排序，归并排序也是从局部入手，将庞大复杂的数据<strong>向下逐层拆分成小的局部数组</strong>，再进行<strong>逐层向上的整合</strong>，从而实现高速的排序。我们直接上代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> L[MAX / <span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> R[MAX / <span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 归并排序算法核心</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>{</span><br><span class="line">	<span class="type">int</span> n1 = mid - left;</span><br><span class="line">	<span class="type">int</span> n2 = right - mid;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n1;i++) L[i] = A[left + i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n2;i++) R[i] = A[mid + i];</span><br><span class="line">	L[n1] = R[n2] = SENTINAL;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="comment">// 注意合并方式！</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = left;k &lt; right;k++) {</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">if</span> (L[i] &lt;= R[j]) A[k] = L[i++];</span><br><span class="line">		<span class="keyword">else</span> A[k] = R[j++];</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>{</span><br><span class="line">	<span class="comment">// 分割至倒数第二层时 left=t, mid=t+1, right=t+2</span></span><br><span class="line">	<span class="comment">// 分割至最后一层，'局部数组'变成了单个元素</span></span><br><span class="line">	<span class="comment">// 最终形成'树'的结构</span></span><br><span class="line">	<span class="comment">// 此时 merge 的对象为两个单元素数组</span></span><br><span class="line">	<span class="keyword">if</span> (left + <span class="number">1</span> &lt; right) {</span><br><span class="line">		<span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">mergeSort</span>(A, n, left, mid);</span><br><span class="line">		<span class="built_in">mergeSort</span>(A, n, mid, right);</span><br><span class="line">		<span class="built_in">merge</span>(A, n, left, mid, right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>归并排序的核心是merge函数，逐层分割后的局部数组在merge函数的整合下，每一层的复杂度是O(n_left+n_right)<strong>，于是整个算法的复杂度为O(N*logN)。<br>我们容易看出，只要元素出现在其键值相等的其他元素之前，其在分割与整合后就一定在其他元素之前，所以归并排序是稳定的。<br>但要注意的是，虽然归并排序稳定高效，但是它却</strong>需要额外的内存来储存分割出来的临时数组，占据额外的空间</strong>。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序可以说是运用最为广泛的排序算法了，它稳定高效，C++的STL库函数sort( ) 就是基于快速排序的函数。 快速排序基于递归法，在分割的同时对数据进行排序与调换：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i, j, t, temp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	temp = randarr[left];</span><br><span class="line">	i = left;  j = right;</span><br><span class="line">	<span class="keyword">while</span> (i != j) {</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (randarr[j] &gt;= temp &amp;&amp; i &lt; j) j--; <span class="comment">// i循环</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (randarr[i] &lt;= temp &amp;&amp; i &lt; j) i++; <span class="comment">// j循环</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) {</span><br><span class="line">			t = randarr[i];</span><br><span class="line">			randarr[i] = randarr[j];</span><br><span class="line">			randarr[j] = t;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	randarr[left] = randarr[i];</span><br><span class="line">	randarr[i] = temp;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">quicksort</span>(left, i - <span class="number">1</span>);  <span class="comment">//左递归</span></span><br><span class="line">	<span class="built_in">quicksort</span>(i + <span class="number">1</span>, right); <span class="comment">//右递归</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>主函数调用时需要传递初始参数，即 quicksort(0,n-1)。 观察上述代码，i、j 即为所谓的标兵节点。<strong>第一轮</strong>调用时，i从0，j从n-1开始，<strong>选择 arr[0] 为比较基准，储存在temp中</strong>。<strong>i和j while循环中，i寻找比temp大的节点，j寻找比temp小的节点</strong>；i、j 不可错位(设置适宜的循环条件)。i和j 循环结束时，如果是因为i==j，则结束外层循环，进入下一步；而如果是因为找到了目标节点，则两个值互换，继续执行代码； 无论如何，<strong>只要外层while循环结束，i和j 相遇在同一节点</strong>，再将arr[left]的值换到i位置，<strong>此时 i(j) 之前的元素都小于等于temp，之后的元素都大于等于temp</strong>。 进行递归调用<code>quicksort(left, i - 1);  //左递归     quicksort(i + 1, right); //右递归</code>，即将左右分别再次执行一次上述操作，直到left=right(局部数组为单个元素)返回，此时，排序就完成了。<br>上述的只是快速排序基准选择的一个方式，还有很多根据实际情况的方式，但思路大体一致，本文不再赘述。</p>
<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>计数排序相对简单，它善于处理元素为正整数的情况，具有极高的效率，但是其元素的最大值具有限制，否则会导致栈溢出：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountingSort</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) {</span><br><span class="line">		C[A[i]]++; <span class="comment">// A 中每个元素出现次数</span></span><br><span class="line">	} </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt;= MAX;j++) {</span><br><span class="line">		C[j] = C[j] + C[j - <span class="number">1</span>]; <span class="comment">// 注意，因为A[i] 可能等于0 C的下标从0开始</span></span><br><span class="line">	} <span class="comment">// 算法核心，通过逐项求和 C[X]表示还有多少小于等于X的项，即该放到第几位</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) {</span><br><span class="line">		B[C[A[i]]] = A[i];</span><br><span class="line">		C[A[i]]--; <span class="comment">// 自减保证值相同项的放置</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>为了表达方便，A下标从0开始。<br>第一个for循环结束，<strong>C[k] 的值即为A中值为k的元素出现的次数</strong>。再把C逐项累加，那么此时<strong>C[k]的值就表示A值为k的元素放置于排序完成数组B中的位置</strong>，也表示<strong>A中包含几个小于等于K的元素</strong>。计数排序能在O(N+Max)的线性时间完成排序，效率可以说非常高了。</p>
<h3 id="打个总结"><a href="#打个总结" class="headerlink" title="打个总结"></a>打个总结</h3><p>以上就是常见的排序算法了，其实不难看出，没有最好的排序算法，只有最适宜的排序方法，我们要根据实际情况来选择使用算法。对其他算法也是一样，我们要因地制宜，在不同情形下选择最优解；有些时候可能没有现成的方法让我们直接使用，这时候就需要分析问题，解决问题的能力，站在前人们的肩膀上，用这些思路创新开发出合适的方法。<br>笔者虽然仔细核对过文中附如的代码，但是难免疏漏，有问题或建议欢迎留言，谢谢。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
</search>
